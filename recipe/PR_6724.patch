From 6af2231df973dd2fa43d29528086d20eb90e35b5 Mon Sep 17 00:00:00 2001
From: Serhiy Storchaka <storchaka@gmail.com>
Date: Tue, 8 May 2018 07:53:20 +0300
Subject: [PATCH] bpo-33096: Removed unintentionally backported from Python 3
 Tkinter files.

This partially reverts commit e80a232f2cfdab584133d9779c83885c5f9f1ba6.
---
 Lib/tkinter/test/test_ttk/test_widgets.py          | 1872 --------------------
 Lib/tkinter/ttk.py                                 | 1660 -----------------
 .../2018-05-08-08-03-34.bpo-33096.0hsFhL.rst       |    1 +
 3 files changed, 1 insertion(+), 3532 deletions(-)
 delete mode 100644 Lib/tkinter/test/test_ttk/test_widgets.py
 delete mode 100644 Lib/tkinter/ttk.py
 create mode 100644 Misc/NEWS.d/next/Library/2018-05-08-08-03-34.bpo-33096.0hsFhL.rst

diff --git Lib/tkinter/test/test_ttk/test_widgets.py Lib/tkinter/test/test_ttk/test_widgets.py
deleted file mode 100644
index 5b0e29cdccaf..000000000000
--- Lib/tkinter/test/test_ttk/test_widgets.py
+++ /dev/null
@@ -1,1872 +0,0 @@
-import unittest
-import tkinter
-from tkinter import ttk, TclError
-from test.support import requires
-import sys
-
-from tkinter.test.test_ttk.test_functions import MockTclObj
-from tkinter.test.support import (AbstractTkTest, tcl_version, get_tk_patchlevel,
-                                  simulate_mouse_click)
-from tkinter.test.widget_tests import (add_standard_options, noconv,
-    AbstractWidgetTest, StandardOptionsTests, IntegerSizeTests, PixelSizeTests,
-    setUpModule)
-
-requires('gui')
-
-
-class StandardTtkOptionsTests(StandardOptionsTests):
-
-    def test_class(self):
-        widget = self.create()
-        self.assertEqual(widget['class'], '')
-        errmsg='attempt to change read-only option'
-        if get_tk_patchlevel() < (8, 6, 0, 'beta', 3):
-            errmsg='Attempt to change read-only option'
-        self.checkInvalidParam(widget, 'class', 'Foo', errmsg=errmsg)
-        widget2 = self.create(class_='Foo')
-        self.assertEqual(widget2['class'], 'Foo')
-
-    def test_padding(self):
-        widget = self.create()
-        self.checkParam(widget, 'padding', 0, expected=('0',))
-        self.checkParam(widget, 'padding', 5, expected=('5',))
-        self.checkParam(widget, 'padding', (5, 6), expected=('5', '6'))
-        self.checkParam(widget, 'padding', (5, 6, 7),
-                        expected=('5', '6', '7'))
-        self.checkParam(widget, 'padding', (5, 6, 7, 8),
-                        expected=('5', '6', '7', '8'))
-        self.checkParam(widget, 'padding', ('5p', '6p', '7p', '8p'))
-        self.checkParam(widget, 'padding', (), expected='')
-
-    def test_style(self):
-        widget = self.create()
-        self.assertEqual(widget['style'], '')
-        errmsg = 'Layout Foo not found'
-        if hasattr(self, 'default_orient'):
-            errmsg = ('Layout %s.Foo not found' %
-                      getattr(self, 'default_orient').title())
-        self.checkInvalidParam(widget, 'style', 'Foo',
-                errmsg=errmsg)
-        widget2 = self.create(class_='Foo')
-        self.assertEqual(widget2['class'], 'Foo')
-        # XXX
-        pass
-
-
-class WidgetTest(AbstractTkTest, unittest.TestCase):
-    """Tests methods available in every ttk widget."""
-
-    def setUp(self):
-        super().setUp()
-        self.widget = ttk.Button(self.root, width=0, text="Text")
-        self.widget.pack()
-        self.widget.wait_visibility()
-
-
-    def test_identify(self):
-        self.widget.update_idletasks()
-        self.assertEqual(self.widget.identify(
-            int(self.widget.winfo_width() / 2),
-            int(self.widget.winfo_height() / 2)
-            ), "label")
-        self.assertEqual(self.widget.identify(-1, -1), "")
-
-        self.assertRaises(tkinter.TclError, self.widget.identify, None, 5)
-        self.assertRaises(tkinter.TclError, self.widget.identify, 5, None)
-        self.assertRaises(tkinter.TclError, self.widget.identify, 5, '')
-
-
-    def test_widget_state(self):
-        # XXX not sure about the portability of all these tests
-        self.assertEqual(self.widget.state(), ())
-        self.assertEqual(self.widget.instate(['!disabled']), True)
-
-        # changing from !disabled to disabled
-        self.assertEqual(self.widget.state(['disabled']), ('!disabled', ))
-        # no state change
-        self.assertEqual(self.widget.state(['disabled']), ())
-        # change back to !disable but also active
-        self.assertEqual(self.widget.state(['!disabled', 'active']),
-            ('!active', 'disabled'))
-        # no state changes, again
-        self.assertEqual(self.widget.state(['!disabled', 'active']), ())
-        self.assertEqual(self.widget.state(['active', '!disabled']), ())
-
-        def test_cb(arg1, **kw):
-            return arg1, kw
-        self.assertEqual(self.widget.instate(['!disabled'],
-            test_cb, "hi", **{"msg": "there"}),
-            ('hi', {'msg': 'there'}))
-
-        # attempt to set invalid statespec
-        currstate = self.widget.state()
-        self.assertRaises(tkinter.TclError, self.widget.instate,
-            ['badstate'])
-        self.assertRaises(tkinter.TclError, self.widget.instate,
-            ['disabled', 'badstate'])
-        # verify that widget didn't change its state
-        self.assertEqual(currstate, self.widget.state())
-
-        # ensuring that passing None as state doesn't modify current state
-        self.widget.state(['active', '!disabled'])
-        self.assertEqual(self.widget.state(), ('active', ))
-
-
-class AbstractToplevelTest(AbstractWidgetTest, PixelSizeTests):
-    _conv_pixels = noconv
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class FrameTest(AbstractToplevelTest, unittest.TestCase):
-    OPTIONS = (
-        'borderwidth', 'class', 'cursor', 'height',
-        'padding', 'relief', 'style', 'takefocus',
-        'width',
-    )
-
-    def create(self, **kwargs):
-        return ttk.Frame(self.root, **kwargs)
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class LabelFrameTest(AbstractToplevelTest, unittest.TestCase):
-    OPTIONS = (
-        'borderwidth', 'class', 'cursor', 'height',
-        'labelanchor', 'labelwidget',
-        'padding', 'relief', 'style', 'takefocus',
-        'text', 'underline', 'width',
-    )
-
-    def create(self, **kwargs):
-        return ttk.LabelFrame(self.root, **kwargs)
-
-    def test_labelanchor(self):
-        widget = self.create()
-        self.checkEnumParam(widget, 'labelanchor',
-                'e', 'en', 'es', 'n', 'ne', 'nw', 's', 'se', 'sw', 'w', 'wn', 'ws',
-                errmsg='Bad label anchor specification {}')
-        self.checkInvalidParam(widget, 'labelanchor', 'center')
-
-    def test_labelwidget(self):
-        widget = self.create()
-        label = ttk.Label(self.root, text='Mupp', name='foo')
-        self.checkParam(widget, 'labelwidget', label, expected='.foo')
-        label.destroy()
-
-
-class AbstractLabelTest(AbstractWidgetTest):
-
-    def checkImageParam(self, widget, name):
-        image = tkinter.PhotoImage(master=self.root, name='image1')
-        image2 = tkinter.PhotoImage(master=self.root, name='image2')
-        self.checkParam(widget, name, image, expected=('image1',))
-        self.checkParam(widget, name, 'image1', expected=('image1',))
-        self.checkParam(widget, name, (image,), expected=('image1',))
-        self.checkParam(widget, name, (image, 'active', image2),
-                        expected=('image1', 'active', 'image2'))
-        self.checkParam(widget, name, 'image1 active image2',
-                        expected=('image1', 'active', 'image2'))
-        self.checkInvalidParam(widget, name, 'spam',
-                errmsg='image "spam" doesn\'t exist')
-
-    def test_compound(self):
-        widget = self.create()
-        self.checkEnumParam(widget, 'compound',
-                'none', 'text', 'image', 'center',
-                'top', 'bottom', 'left', 'right')
-
-    def test_state(self):
-        widget = self.create()
-        self.checkParams(widget, 'state', 'active', 'disabled', 'normal')
-
-    def test_width(self):
-        widget = self.create()
-        self.checkParams(widget, 'width', 402, -402, 0)
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class LabelTest(AbstractLabelTest, unittest.TestCase):
-    OPTIONS = (
-        'anchor', 'background', 'borderwidth',
-        'class', 'compound', 'cursor', 'font', 'foreground',
-        'image', 'justify', 'padding', 'relief', 'state', 'style',
-        'takefocus', 'text', 'textvariable',
-        'underline', 'width', 'wraplength',
-    )
-    _conv_pixels = noconv
-
-    def create(self, **kwargs):
-        return ttk.Label(self.root, **kwargs)
-
-    def test_font(self):
-        widget = self.create()
-        self.checkParam(widget, 'font',
-                        '-Adobe-Helvetica-Medium-R-Normal--*-120-*-*-*-*-*-*')
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class ButtonTest(AbstractLabelTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'command', 'compound', 'cursor', 'default',
-        'image', 'padding', 'state', 'style',
-        'takefocus', 'text', 'textvariable',
-        'underline', 'width',
-    )
-
-    def create(self, **kwargs):
-        return ttk.Button(self.root, **kwargs)
-
-    def test_default(self):
-        widget = self.create()
-        self.checkEnumParam(widget, 'default', 'normal', 'active', 'disabled')
-
-    def test_invoke(self):
-        success = []
-        btn = ttk.Button(self.root, command=lambda: success.append(1))
-        btn.invoke()
-        self.assertTrue(success)
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class CheckbuttonTest(AbstractLabelTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'command', 'compound', 'cursor',
-        'image',
-        'offvalue', 'onvalue',
-        'padding', 'state', 'style',
-        'takefocus', 'text', 'textvariable',
-        'underline', 'variable', 'width',
-    )
-
-    def create(self, **kwargs):
-        return ttk.Checkbutton(self.root, **kwargs)
-
-    def test_offvalue(self):
-        widget = self.create()
-        self.checkParams(widget, 'offvalue', 1, 2.3, '', 'any string')
-
-    def test_onvalue(self):
-        widget = self.create()
-        self.checkParams(widget, 'onvalue', 1, 2.3, '', 'any string')
-
-    def test_invoke(self):
-        success = []
-        def cb_test():
-            success.append(1)
-            return "cb test called"
-
-        cbtn = ttk.Checkbutton(self.root, command=cb_test)
-        # the variable automatically created by ttk.Checkbutton is actually
-        # undefined till we invoke the Checkbutton
-        self.assertEqual(cbtn.state(), ('alternate', ))
-        self.assertRaises(tkinter.TclError, cbtn.tk.globalgetvar,
-            cbtn['variable'])
-
-        res = cbtn.invoke()
-        self.assertEqual(res, "cb test called")
-        self.assertEqual(cbtn['onvalue'],
-            cbtn.tk.globalgetvar(cbtn['variable']))
-        self.assertTrue(success)
-
-        cbtn['command'] = ''
-        res = cbtn.invoke()
-        self.assertFalse(str(res))
-        self.assertLessEqual(len(success), 1)
-        self.assertEqual(cbtn['offvalue'],
-            cbtn.tk.globalgetvar(cbtn['variable']))
-
-
-@add_standard_options(IntegerSizeTests, StandardTtkOptionsTests)
-class EntryTest(AbstractWidgetTest, unittest.TestCase):
-    OPTIONS = (
-        'background', 'class', 'cursor',
-        'exportselection', 'font', 'foreground',
-        'invalidcommand', 'justify',
-        'show', 'state', 'style', 'takefocus', 'textvariable',
-        'validate', 'validatecommand', 'width', 'xscrollcommand',
-    )
-
-    def setUp(self):
-        super().setUp()
-        self.entry = self.create()
-
-    def create(self, **kwargs):
-        return ttk.Entry(self.root, **kwargs)
-
-    def test_invalidcommand(self):
-        widget = self.create()
-        self.checkCommandParam(widget, 'invalidcommand')
-
-    def test_show(self):
-        widget = self.create()
-        self.checkParam(widget, 'show', '*')
-        self.checkParam(widget, 'show', '')
-        self.checkParam(widget, 'show', ' ')
-
-    def test_state(self):
-        widget = self.create()
-        self.checkParams(widget, 'state',
-                         'disabled', 'normal', 'readonly')
-
-    def test_validate(self):
-        widget = self.create()
-        self.checkEnumParam(widget, 'validate',
-                'all', 'key', 'focus', 'focusin', 'focusout', 'none')
-
-    def test_validatecommand(self):
-        widget = self.create()
-        self.checkCommandParam(widget, 'validatecommand')
-
-
-    def test_bbox(self):
-        self.assertIsBoundingBox(self.entry.bbox(0))
-        self.assertRaises(tkinter.TclError, self.entry.bbox, 'noindex')
-        self.assertRaises(tkinter.TclError, self.entry.bbox, None)
-
-
-    def test_identify(self):
-        self.entry.pack()
-        self.entry.wait_visibility()
-        self.entry.update_idletasks()
-
-        self.assertEqual(self.entry.identify(5, 5), "textarea")
-        self.assertEqual(self.entry.identify(-1, -1), "")
-
-        self.assertRaises(tkinter.TclError, self.entry.identify, None, 5)
-        self.assertRaises(tkinter.TclError, self.entry.identify, 5, None)
-        self.assertRaises(tkinter.TclError, self.entry.identify, 5, '')
-
-
-    def test_validation_options(self):
-        success = []
-        test_invalid = lambda: success.append(True)
-
-        self.entry['validate'] = 'none'
-        self.entry['validatecommand'] = lambda: False
-
-        self.entry['invalidcommand'] = test_invalid
-        self.entry.validate()
-        self.assertTrue(success)
-
-        self.entry['invalidcommand'] = ''
-        self.entry.validate()
-        self.assertEqual(len(success), 1)
-
-        self.entry['invalidcommand'] = test_invalid
-        self.entry['validatecommand'] = lambda: True
-        self.entry.validate()
-        self.assertEqual(len(success), 1)
-
-        self.entry['validatecommand'] = ''
-        self.entry.validate()
-        self.assertEqual(len(success), 1)
-
-        self.entry['validatecommand'] = True
-        self.assertRaises(tkinter.TclError, self.entry.validate)
-
-
-    def test_validation(self):
-        validation = []
-        def validate(to_insert):
-            if not 'a' <= to_insert.lower() <= 'z':
-                validation.append(False)
-                return False
-            validation.append(True)
-            return True
-
-        self.entry['validate'] = 'key'
-        self.entry['validatecommand'] = self.entry.register(validate), '%S'
-
-        self.entry.insert('end', 1)
-        self.entry.insert('end', 'a')
-        self.assertEqual(validation, [False, True])
-        self.assertEqual(self.entry.get(), 'a')
-
-
-    def test_revalidation(self):
-        def validate(content):
-            for letter in content:
-                if not 'a' <= letter.lower() <= 'z':
-                    return False
-            return True
-
-        self.entry['validatecommand'] = self.entry.register(validate), '%P'
-
-        self.entry.insert('end', 'avocado')
-        self.assertEqual(self.entry.validate(), True)
-        self.assertEqual(self.entry.state(), ())
-
-        self.entry.delete(0, 'end')
-        self.assertEqual(self.entry.get(), '')
-
-        self.entry.insert('end', 'a1b')
-        self.assertEqual(self.entry.validate(), False)
-        self.assertEqual(self.entry.state(), ('invalid', ))
-
-        self.entry.delete(1)
-        self.assertEqual(self.entry.validate(), True)
-        self.assertEqual(self.entry.state(), ())
-
-
-@add_standard_options(IntegerSizeTests, StandardTtkOptionsTests)
-class ComboboxTest(EntryTest, unittest.TestCase):
-    OPTIONS = (
-        'background', 'class', 'cursor', 'exportselection',
-        'font', 'foreground', 'height', 'invalidcommand',
-        'justify', 'postcommand', 'show', 'state', 'style',
-        'takefocus', 'textvariable',
-        'validate', 'validatecommand', 'values',
-        'width', 'xscrollcommand',
-    )
-
-    def setUp(self):
-        super().setUp()
-        self.combo = self.create()
-
-    def create(self, **kwargs):
-        return ttk.Combobox(self.root, **kwargs)
-
-    def test_height(self):
-        widget = self.create()
-        self.checkParams(widget, 'height', 100, 101.2, 102.6, -100, 0, '1i')
-
-    def _show_drop_down_listbox(self):
-        width = self.combo.winfo_width()
-        self.combo.event_generate('<ButtonPress-1>', x=width - 5, y=5)
-        self.combo.event_generate('<ButtonRelease-1>', x=width - 5, y=5)
-        self.combo.update_idletasks()
-
-
-    def test_virtual_event(self):
-        success = []
-
-        self.combo['values'] = [1]
-        self.combo.bind('<<ComboboxSelected>>',
-            lambda evt: success.append(True))
-        self.combo.pack()
-        self.combo.wait_visibility()
-
-        height = self.combo.winfo_height()
-        self._show_drop_down_listbox()
-        self.combo.update()
-        self.combo.event_generate('<Return>')
-        self.combo.update()
-
-        self.assertTrue(success)
-
-
-    def test_postcommand(self):
-        success = []
-
-        self.combo['postcommand'] = lambda: success.append(True)
-        self.combo.pack()
-        self.combo.wait_visibility()
-
-        self._show_drop_down_listbox()
-        self.assertTrue(success)
-
-        # testing postcommand removal
-        self.combo['postcommand'] = ''
-        self._show_drop_down_listbox()
-        self.assertEqual(len(success), 1)
-
-
-    def test_values(self):
-        def check_get_current(getval, currval):
-            self.assertEqual(self.combo.get(), getval)
-            self.assertEqual(self.combo.current(), currval)
-
-        self.assertEqual(self.combo['values'],
-                         () if tcl_version < (8, 5) else '')
-        check_get_current('', -1)
-
-        self.checkParam(self.combo, 'values', 'mon tue wed thur',
-                        expected=('mon', 'tue', 'wed', 'thur'))
-        self.checkParam(self.combo, 'values', ('mon', 'tue', 'wed', 'thur'))
-        self.checkParam(self.combo, 'values', (42, 3.14, '', 'any string'))
-        self.checkParam(self.combo, 'values', '',
-                        expected='' if get_tk_patchlevel() < (8, 5, 10) else ())
-
-        self.combo['values'] = ['a', 1, 'c']
-
-        self.combo.set('c')
-        check_get_current('c', 2)
-
-        self.combo.current(0)
-        check_get_current('a', 0)
-
-        self.combo.set('d')
-        check_get_current('d', -1)
-
-        # testing values with empty string
-        self.combo.set('')
-        self.combo['values'] = (1, 2, '', 3)
-        check_get_current('', 2)
-
-        # testing values with empty string set through configure
-        self.combo.configure(values=[1, '', 2])
-        self.assertEqual(self.combo['values'],
-                         ('1', '', '2') if self.wantobjects else
-                         '1 {} 2')
-
-        # testing values with spaces
-        self.combo['values'] = ['a b', 'a\tb', 'a\nb']
-        self.assertEqual(self.combo['values'],
-                         ('a b', 'a\tb', 'a\nb') if self.wantobjects else
-                         '{a b} {a\tb} {a\nb}')
-
-        # testing values with special characters
-        self.combo['values'] = [r'a\tb', '"a"', '} {']
-        self.assertEqual(self.combo['values'],
-                         (r'a\tb', '"a"', '} {') if self.wantobjects else
-                         r'a\\tb {"a"} \}\ \{')
-
-        # out of range
-        self.assertRaises(tkinter.TclError, self.combo.current,
-            len(self.combo['values']))
-        # it expects an integer (or something that can be converted to int)
-        self.assertRaises(tkinter.TclError, self.combo.current, '')
-
-        # testing creating combobox with empty string in values
-        combo2 = ttk.Combobox(self.root, values=[1, 2, ''])
-        self.assertEqual(combo2['values'],
-                         ('1', '2', '') if self.wantobjects else '1 2 {}')
-        combo2.destroy()
-
-
-@add_standard_options(IntegerSizeTests, StandardTtkOptionsTests)
-class PanedWindowTest(AbstractWidgetTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'cursor', 'height',
-        'orient', 'style', 'takefocus', 'width',
-    )
-
-    def setUp(self):
-        super().setUp()
-        self.paned = self.create()
-
-    def create(self, **kwargs):
-        return ttk.PanedWindow(self.root, **kwargs)
-
-    def test_orient(self):
-        widget = self.create()
-        self.assertEqual(str(widget['orient']), 'vertical')
-        errmsg='attempt to change read-only option'
-        if get_tk_patchlevel() < (8, 6, 0, 'beta', 3):
-            errmsg='Attempt to change read-only option'
-        self.checkInvalidParam(widget, 'orient', 'horizontal',
-                errmsg=errmsg)
-        widget2 = self.create(orient='horizontal')
-        self.assertEqual(str(widget2['orient']), 'horizontal')
-
-    def test_add(self):
-        # attempt to add a child that is not a direct child of the paned window
-        label = ttk.Label(self.paned)
-        child = ttk.Label(label)
-        self.assertRaises(tkinter.TclError, self.paned.add, child)
-        label.destroy()
-        child.destroy()
-        # another attempt
-        label = ttk.Label(self.root)
-        child = ttk.Label(label)
-        self.assertRaises(tkinter.TclError, self.paned.add, child)
-        child.destroy()
-        label.destroy()
-
-        good_child = ttk.Label(self.root)
-        self.paned.add(good_child)
-        # re-adding a child is not accepted
-        self.assertRaises(tkinter.TclError, self.paned.add, good_child)
-
-        other_child = ttk.Label(self.paned)
-        self.paned.add(other_child)
-        self.assertEqual(self.paned.pane(0), self.paned.pane(1))
-        self.assertRaises(tkinter.TclError, self.paned.pane, 2)
-        good_child.destroy()
-        other_child.destroy()
-        self.assertRaises(tkinter.TclError, self.paned.pane, 0)
-
-
-    def test_forget(self):
-        self.assertRaises(tkinter.TclError, self.paned.forget, None)
-        self.assertRaises(tkinter.TclError, self.paned.forget, 0)
-
-        self.paned.add(ttk.Label(self.root))
-        self.paned.forget(0)
-        self.assertRaises(tkinter.TclError, self.paned.forget, 0)
-
-
-    def test_insert(self):
-        self.assertRaises(tkinter.TclError, self.paned.insert, None, 0)
-        self.assertRaises(tkinter.TclError, self.paned.insert, 0, None)
-        self.assertRaises(tkinter.TclError, self.paned.insert, 0, 0)
-
-        child = ttk.Label(self.root)
-        child2 = ttk.Label(self.root)
-        child3 = ttk.Label(self.root)
-
-        self.assertRaises(tkinter.TclError, self.paned.insert, 0, child)
-
-        self.paned.insert('end', child2)
-        self.paned.insert(0, child)
-        self.assertEqual(self.paned.panes(), (str(child), str(child2)))
-
-        self.paned.insert(0, child2)
-        self.assertEqual(self.paned.panes(), (str(child2), str(child)))
-
-        self.paned.insert('end', child3)
-        self.assertEqual(self.paned.panes(),
-            (str(child2), str(child), str(child3)))
-
-        # reinserting a child should move it to its current position
-        panes = self.paned.panes()
-        self.paned.insert('end', child3)
-        self.assertEqual(panes, self.paned.panes())
-
-        # moving child3 to child2 position should result in child2 ending up
-        # in previous child position and child ending up in previous child3
-        # position
-        self.paned.insert(child2, child3)
-        self.assertEqual(self.paned.panes(),
-            (str(child3), str(child2), str(child)))
-
-
-    def test_pane(self):
-        self.assertRaises(tkinter.TclError, self.paned.pane, 0)
-
-        child = ttk.Label(self.root)
-        self.paned.add(child)
-        self.assertIsInstance(self.paned.pane(0), dict)
-        self.assertEqual(self.paned.pane(0, weight=None),
-                         0 if self.wantobjects else '0')
-        # newer form for querying a single option
-        self.assertEqual(self.paned.pane(0, 'weight'),
-                         0 if self.wantobjects else '0')
-        self.assertEqual(self.paned.pane(0), self.paned.pane(str(child)))
-
-        self.assertRaises(tkinter.TclError, self.paned.pane, 0,
-            badoption='somevalue')
-
-
-    def test_sashpos(self):
-        self.assertRaises(tkinter.TclError, self.paned.sashpos, None)
-        self.assertRaises(tkinter.TclError, self.paned.sashpos, '')
-        self.assertRaises(tkinter.TclError, self.paned.sashpos, 0)
-
-        child = ttk.Label(self.paned, text='a')
-        self.paned.add(child, weight=1)
-        self.assertRaises(tkinter.TclError, self.paned.sashpos, 0)
-        child2 = ttk.Label(self.paned, text='b')
-        self.paned.add(child2)
-        self.assertRaises(tkinter.TclError, self.paned.sashpos, 1)
-
-        self.paned.pack(expand=True, fill='both')
-        self.paned.wait_visibility()
-
-        curr_pos = self.paned.sashpos(0)
-        self.paned.sashpos(0, 1000)
-        self.assertNotEqual(curr_pos, self.paned.sashpos(0))
-        self.assertIsInstance(self.paned.sashpos(0), int)
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class RadiobuttonTest(AbstractLabelTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'command', 'compound', 'cursor',
-        'image',
-        'padding', 'state', 'style',
-        'takefocus', 'text', 'textvariable',
-        'underline', 'value', 'variable', 'width',
-    )
-
-    def create(self, **kwargs):
-        return ttk.Radiobutton(self.root, **kwargs)
-
-    def test_value(self):
-        widget = self.create()
-        self.checkParams(widget, 'value', 1, 2.3, '', 'any string')
-
-    def test_invoke(self):
-        success = []
-        def cb_test():
-            success.append(1)
-            return "cb test called"
-
-        myvar = tkinter.IntVar(self.root)
-        cbtn = ttk.Radiobutton(self.root, command=cb_test,
-                               variable=myvar, value=0)
-        cbtn2 = ttk.Radiobutton(self.root, command=cb_test,
-                                variable=myvar, value=1)
-
-        if self.wantobjects:
-            conv = lambda x: x
-        else:
-            conv = int
-
-        res = cbtn.invoke()
-        self.assertEqual(res, "cb test called")
-        self.assertEqual(conv(cbtn['value']), myvar.get())
-        self.assertEqual(myvar.get(),
-            conv(cbtn.tk.globalgetvar(cbtn['variable'])))
-        self.assertTrue(success)
-
-        cbtn2['command'] = ''
-        res = cbtn2.invoke()
-        self.assertEqual(str(res), '')
-        self.assertLessEqual(len(success), 1)
-        self.assertEqual(conv(cbtn2['value']), myvar.get())
-        self.assertEqual(myvar.get(),
-            conv(cbtn.tk.globalgetvar(cbtn['variable'])))
-
-        self.assertEqual(str(cbtn['variable']), str(cbtn2['variable']))
-
-
-class MenubuttonTest(AbstractLabelTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'compound', 'cursor', 'direction',
-        'image', 'menu', 'padding', 'state', 'style',
-        'takefocus', 'text', 'textvariable',
-        'underline', 'width',
-    )
-
-    def create(self, **kwargs):
-        return ttk.Menubutton(self.root, **kwargs)
-
-    def test_direction(self):
-        widget = self.create()
-        self.checkEnumParam(widget, 'direction',
-                'above', 'below', 'left', 'right', 'flush')
-
-    def test_menu(self):
-        widget = self.create()
-        menu = tkinter.Menu(widget, name='menu')
-        self.checkParam(widget, 'menu', menu, conv=str)
-        menu.destroy()
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class ScaleTest(AbstractWidgetTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'command', 'cursor', 'from', 'length',
-        'orient', 'style', 'takefocus', 'to', 'value', 'variable',
-    )
-    _conv_pixels = noconv
-    default_orient = 'horizontal'
-
-    def setUp(self):
-        super().setUp()
-        self.scale = self.create()
-        self.scale.pack()
-        self.scale.update()
-
-    def create(self, **kwargs):
-        return ttk.Scale(self.root, **kwargs)
-
-    def test_from(self):
-        widget = self.create()
-        self.checkFloatParam(widget, 'from', 100, 14.9, 15.1, conv=False)
-
-    def test_length(self):
-        widget = self.create()
-        self.checkPixelsParam(widget, 'length', 130, 131.2, 135.6, '5i')
-
-    def test_to(self):
-        widget = self.create()
-        self.checkFloatParam(widget, 'to', 300, 14.9, 15.1, -10, conv=False)
-
-    def test_value(self):
-        widget = self.create()
-        self.checkFloatParam(widget, 'value', 300, 14.9, 15.1, -10, conv=False)
-
-    def test_custom_event(self):
-        failure = [1, 1, 1] # will need to be empty
-
-        funcid = self.scale.bind('<<RangeChanged>>', lambda evt: failure.pop())
-
-        self.scale['from'] = 10
-        self.scale['from_'] = 10
-        self.scale['to'] = 3
-
-        self.assertFalse(failure)
-
-        failure = [1, 1, 1]
-        self.scale.configure(from_=2, to=5)
-        self.scale.configure(from_=0, to=-2)
-        self.scale.configure(to=10)
-
-        self.assertFalse(failure)
-
-
-    def test_get(self):
-        if self.wantobjects:
-            conv = lambda x: x
-        else:
-            conv = float
-
-        scale_width = self.scale.winfo_width()
-        self.assertEqual(self.scale.get(scale_width, 0), self.scale['to'])
-
-        self.assertEqual(conv(self.scale.get(0, 0)), conv(self.scale['from']))
-        self.assertEqual(self.scale.get(), self.scale['value'])
-        self.scale['value'] = 30
-        self.assertEqual(self.scale.get(), self.scale['value'])
-
-        self.assertRaises(tkinter.TclError, self.scale.get, '', 0)
-        self.assertRaises(tkinter.TclError, self.scale.get, 0, '')
-
-
-    def test_set(self):
-        if self.wantobjects:
-            conv = lambda x: x
-        else:
-            conv = float
-
-        # set restricts the max/min values according to the current range
-        max = conv(self.scale['to'])
-        new_max = max + 10
-        self.scale.set(new_max)
-        self.assertEqual(conv(self.scale.get()), max)
-        min = conv(self.scale['from'])
-        self.scale.set(min - 1)
-        self.assertEqual(conv(self.scale.get()), min)
-
-        # changing directly the variable doesn't impose this limitation tho
-        var = tkinter.DoubleVar(self.root)
-        self.scale['variable'] = var
-        var.set(max + 5)
-        self.assertEqual(conv(self.scale.get()), var.get())
-        self.assertEqual(conv(self.scale.get()), max + 5)
-        del var
-
-        # the same happens with the value option
-        self.scale['value'] = max + 10
-        self.assertEqual(conv(self.scale.get()), max + 10)
-        self.assertEqual(conv(self.scale.get()), conv(self.scale['value']))
-
-        # nevertheless, note that the max/min values we can get specifying
-        # x, y coords are the ones according to the current range
-        self.assertEqual(conv(self.scale.get(0, 0)), min)
-        self.assertEqual(conv(self.scale.get(self.scale.winfo_width(), 0)), max)
-
-        self.assertRaises(tkinter.TclError, self.scale.set, None)
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class ProgressbarTest(AbstractWidgetTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'cursor', 'orient', 'length',
-        'mode', 'maximum', 'phase',
-        'style', 'takefocus', 'value', 'variable',
-    )
-    _conv_pixels = noconv
-    default_orient = 'horizontal'
-
-    def create(self, **kwargs):
-        return ttk.Progressbar(self.root, **kwargs)
-
-    def test_length(self):
-        widget = self.create()
-        self.checkPixelsParam(widget, 'length', 100.1, 56.7, '2i')
-
-    def test_maximum(self):
-        widget = self.create()
-        self.checkFloatParam(widget, 'maximum', 150.2, 77.7, 0, -10, conv=False)
-
-    def test_mode(self):
-        widget = self.create()
-        self.checkEnumParam(widget, 'mode', 'determinate', 'indeterminate')
-
-    def test_phase(self):
-        # XXX
-        pass
-
-    def test_value(self):
-        widget = self.create()
-        self.checkFloatParam(widget, 'value', 150.2, 77.7, 0, -10,
-                             conv=False)
-
-
-@unittest.skipIf(sys.platform == 'darwin',
-                 'ttk.Scrollbar is special on MacOSX')
-@add_standard_options(StandardTtkOptionsTests)
-class ScrollbarTest(AbstractWidgetTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'command', 'cursor', 'orient', 'style', 'takefocus',
-    )
-    default_orient = 'vertical'
-
-    def create(self, **kwargs):
-        return ttk.Scrollbar(self.root, **kwargs)
-
-
-@add_standard_options(IntegerSizeTests, StandardTtkOptionsTests)
-class NotebookTest(AbstractWidgetTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'cursor', 'height', 'padding', 'style', 'takefocus', 'width',
-    )
-
-    def setUp(self):
-        super().setUp()
-        self.nb = self.create(padding=0)
-        self.child1 = ttk.Label(self.root)
-        self.child2 = ttk.Label(self.root)
-        self.nb.add(self.child1, text='a')
-        self.nb.add(self.child2, text='b')
-
-    def create(self, **kwargs):
-        return ttk.Notebook(self.root, **kwargs)
-
-    def test_tab_identifiers(self):
-        self.nb.forget(0)
-        self.nb.hide(self.child2)
-        self.assertRaises(tkinter.TclError, self.nb.tab, self.child1)
-        self.assertEqual(self.nb.index('end'), 1)
-        self.nb.add(self.child2)
-        self.assertEqual(self.nb.index('end'), 1)
-        self.nb.select(self.child2)
-
-        self.assertTrue(self.nb.tab('current'))
-        self.nb.add(self.child1, text='a')
-
-        self.nb.pack()
-        self.nb.wait_visibility()
-        if sys.platform == 'darwin':
-            tb_idx = "@20,5"
-        else:
-            tb_idx = "@5,5"
-        self.assertEqual(self.nb.tab(tb_idx), self.nb.tab('current'))
-
-        for i in range(5, 100, 5):
-            try:
-                if self.nb.tab('@%d, 5' % i, text=None) == 'a':
-                    break
-            except tkinter.TclError:
-                pass
-
-        else:
-            self.fail("Tab with text 'a' not found")
-
-
-    def test_add_and_hidden(self):
-        self.assertRaises(tkinter.TclError, self.nb.hide, -1)
-        self.assertRaises(tkinter.TclError, self.nb.hide, 'hi')
-        self.assertRaises(tkinter.TclError, self.nb.hide, None)
-        self.assertRaises(tkinter.TclError, self.nb.add, None)
-        self.assertRaises(tkinter.TclError, self.nb.add, ttk.Label(self.root),
-            unknown='option')
-
-        tabs = self.nb.tabs()
-        self.nb.hide(self.child1)
-        self.nb.add(self.child1)
-        self.assertEqual(self.nb.tabs(), tabs)
-
-        child = ttk.Label(self.root)
-        self.nb.add(child, text='c')
-        tabs = self.nb.tabs()
-
-        curr = self.nb.index('current')
-        # verify that the tab gets readded at its previous position
-        child2_index = self.nb.index(self.child2)
-        self.nb.hide(self.child2)
-        self.nb.add(self.child2)
-        self.assertEqual(self.nb.tabs(), tabs)
-        self.assertEqual(self.nb.index(self.child2), child2_index)
-        self.assertEqual(str(self.child2), self.nb.tabs()[child2_index])
-        # but the tab next to it (not hidden) is the one selected now
-        self.assertEqual(self.nb.index('current'), curr + 1)
-
-
-    def test_forget(self):
-        self.assertRaises(tkinter.TclError, self.nb.forget, -1)
-        self.assertRaises(tkinter.TclError, self.nb.forget, 'hi')
-        self.assertRaises(tkinter.TclError, self.nb.forget, None)
-
-        tabs = self.nb.tabs()
-        child1_index = self.nb.index(self.child1)
-        self.nb.forget(self.child1)
-        self.assertNotIn(str(self.child1), self.nb.tabs())
-        self.assertEqual(len(tabs) - 1, len(self.nb.tabs()))
-
-        self.nb.add(self.child1)
-        self.assertEqual(self.nb.index(self.child1), 1)
-        self.assertNotEqual(child1_index, self.nb.index(self.child1))
-
-
-    def test_index(self):
-        self.assertRaises(tkinter.TclError, self.nb.index, -1)
-        self.assertRaises(tkinter.TclError, self.nb.index, None)
-
-        self.assertIsInstance(self.nb.index('end'), int)
-        self.assertEqual(self.nb.index(self.child1), 0)
-        self.assertEqual(self.nb.index(self.child2), 1)
-        self.assertEqual(self.nb.index('end'), 2)
-
-
-    def test_insert(self):
-        # moving tabs
-        tabs = self.nb.tabs()
-        self.nb.insert(1, tabs[0])
-        self.assertEqual(self.nb.tabs(), (tabs[1], tabs[0]))
-        self.nb.insert(self.child1, self.child2)
-        self.assertEqual(self.nb.tabs(), tabs)
-        self.nb.insert('end', self.child1)
-        self.assertEqual(self.nb.tabs(), (tabs[1], tabs[0]))
-        self.nb.insert('end', 0)
-        self.assertEqual(self.nb.tabs(), tabs)
-        # bad moves
-        self.assertRaises(tkinter.TclError, self.nb.insert, 2, tabs[0])
-        self.assertRaises(tkinter.TclError, self.nb.insert, -1, tabs[0])
-
-        # new tab
-        child3 = ttk.Label(self.root)
-        self.nb.insert(1, child3)
-        self.assertEqual(self.nb.tabs(), (tabs[0], str(child3), tabs[1]))
-        self.nb.forget(child3)
-        self.assertEqual(self.nb.tabs(), tabs)
-        self.nb.insert(self.child1, child3)
-        self.assertEqual(self.nb.tabs(), (str(child3), ) + tabs)
-        self.nb.forget(child3)
-        self.assertRaises(tkinter.TclError, self.nb.insert, 2, child3)
-        self.assertRaises(tkinter.TclError, self.nb.insert, -1, child3)
-
-        # bad inserts
-        self.assertRaises(tkinter.TclError, self.nb.insert, 'end', None)
-        self.assertRaises(tkinter.TclError, self.nb.insert, None, 0)
-        self.assertRaises(tkinter.TclError, self.nb.insert, None, None)
-
-
-    def test_select(self):
-        self.nb.pack()
-        self.nb.wait_visibility()
-
-        success = []
-        tab_changed = []
-
-        self.child1.bind('<Unmap>', lambda evt: success.append(True))
-        self.nb.bind('<<NotebookTabChanged>>',
-            lambda evt: tab_changed.append(True))
-
-        self.assertEqual(self.nb.select(), str(self.child1))
-        self.nb.select(self.child2)
-        self.assertTrue(success)
-        self.assertEqual(self.nb.select(), str(self.child2))
-
-        self.nb.update()
-        self.assertTrue(tab_changed)
-
-
-    def test_tab(self):
-        self.assertRaises(tkinter.TclError, self.nb.tab, -1)
-        self.assertRaises(tkinter.TclError, self.nb.tab, 'notab')
-        self.assertRaises(tkinter.TclError, self.nb.tab, None)
-
-        self.assertIsInstance(self.nb.tab(self.child1), dict)
-        self.assertEqual(self.nb.tab(self.child1, text=None), 'a')
-        # newer form for querying a single option
-        self.assertEqual(self.nb.tab(self.child1, 'text'), 'a')
-        self.nb.tab(self.child1, text='abc')
-        self.assertEqual(self.nb.tab(self.child1, text=None), 'abc')
-        self.assertEqual(self.nb.tab(self.child1, 'text'), 'abc')
-
-
-    def test_tabs(self):
-        self.assertEqual(len(self.nb.tabs()), 2)
-
-        self.nb.forget(self.child1)
-        self.nb.forget(self.child2)
-
-        self.assertEqual(self.nb.tabs(), ())
-
-
-    def test_traversal(self):
-        self.nb.pack()
-        self.nb.wait_visibility()
-
-        self.nb.select(0)
-
-        simulate_mouse_click(self.nb, 5, 5)
-        self.nb.focus_force()
-        self.nb.event_generate('<Control-Tab>')
-        self.assertEqual(self.nb.select(), str(self.child2))
-        self.nb.focus_force()
-        self.nb.event_generate('<Shift-Control-Tab>')
-        self.assertEqual(self.nb.select(), str(self.child1))
-        self.nb.focus_force()
-        self.nb.event_generate('<Shift-Control-Tab>')
-        self.assertEqual(self.nb.select(), str(self.child2))
-
-        self.nb.tab(self.child1, text='a', underline=0)
-        self.nb.enable_traversal()
-        self.nb.focus_force()
-        simulate_mouse_click(self.nb, 5, 5)
-        if sys.platform == 'darwin':
-            self.nb.event_generate('<Option-a>')
-        else:
-            self.nb.event_generate('<Alt-a>')
-        self.assertEqual(self.nb.select(), str(self.child1))
-
-@add_standard_options(IntegerSizeTests, StandardTtkOptionsTests)
-class SpinboxTest(EntryTest, unittest.TestCase):
-    OPTIONS = (
-        'background', 'class', 'command', 'cursor', 'exportselection',
-        'font', 'foreground', 'format', 'from',  'increment',
-        'invalidcommand', 'justify', 'show', 'state', 'style',
-        'takefocus', 'textvariable', 'to', 'validate', 'validatecommand',
-        'values', 'width', 'wrap', 'xscrollcommand',
-    )
-
-    def setUp(self):
-        super().setUp()
-        self.spin = self.create()
-        self.spin.pack()
-
-    def create(self, **kwargs):
-        return ttk.Spinbox(self.root, **kwargs)
-
-    def _click_increment_arrow(self):
-        width = self.spin.winfo_width()
-        height = self.spin.winfo_height()
-        x = width - 5
-        y = height//2 - 5
-        self.spin.event_generate('<ButtonPress-1>', x=x, y=y)
-        self.spin.event_generate('<ButtonRelease-1>', x=x, y=y)
-        self.spin.update_idletasks()
-
-    def _click_decrement_arrow(self):
-        width = self.spin.winfo_width()
-        height = self.spin.winfo_height()
-        x = width - 5
-        y = height//2 + 4
-        self.spin.event_generate('<ButtonPress-1>', x=x, y=y)
-        self.spin.event_generate('<ButtonRelease-1>', x=x, y=y)
-        self.spin.update_idletasks()
-
-    def test_command(self):
-        success = []
-
-        self.spin['command'] = lambda: success.append(True)
-        self.spin.update()
-        self._click_increment_arrow()
-        self.spin.update()
-        self.assertTrue(success)
-
-        self._click_decrement_arrow()
-        self.assertEqual(len(success), 2)
-
-        # testing postcommand removal
-        self.spin['command'] = ''
-        self.spin.update_idletasks()
-        self._click_increment_arrow()
-        self._click_decrement_arrow()
-        self.spin.update()
-        self.assertEqual(len(success), 2)
-
-    def test_to(self):
-        self.spin['from'] = 0
-        self.spin['to'] = 5
-        self.spin.set(4)
-        self.spin.update()
-        self._click_increment_arrow()  # 5
-
-        self.assertEqual(self.spin.get(), '5')
-
-        self._click_increment_arrow()  # 5
-        self.assertEqual(self.spin.get(), '5')
-
-    def test_from(self):
-        self.spin['from'] = 1
-        self.spin['to'] = 10
-        self.spin.set(2)
-        self.spin.update()
-        self._click_decrement_arrow()  # 1
-        self.assertEqual(self.spin.get(), '1')
-        self._click_decrement_arrow()  # 1
-        self.assertEqual(self.spin.get(), '1')
-
-    def test_increment(self):
-        self.spin['from'] = 0
-        self.spin['to'] = 10
-        self.spin['increment'] = 4
-        self.spin.set(1)
-        self.spin.update()
-
-        self._click_increment_arrow()  # 5
-        self.assertEqual(self.spin.get(), '5')
-        self.spin['increment'] = 2
-        self.spin.update()
-        self._click_decrement_arrow()  # 3
-        self.assertEqual(self.spin.get(), '3')
-
-    def test_format(self):
-        self.spin.set(1)
-        self.spin['format'] = '%10.3f'
-        self.spin.update()
-        self._click_increment_arrow()
-        value = self.spin.get()
-
-        self.assertEqual(len(value), 10)
-        self.assertEqual(value.index('.'), 6)
-
-        self.spin['format'] = ''
-        self.spin.update()
-        self._click_increment_arrow()
-        value = self.spin.get()
-        self.assertTrue('.' not in value)
-        self.assertEqual(len(value), 1)
-
-    def test_wrap(self):
-        self.spin['to'] = 10
-        self.spin['from'] = 1
-        self.spin.set(1)
-        self.spin['wrap'] = True
-        self.spin.update()
-
-        self._click_decrement_arrow()
-        self.assertEqual(self.spin.get(), '10')
-
-        self._click_increment_arrow()
-        self.assertEqual(self.spin.get(), '1')
-
-        self.spin['wrap'] = False
-        self.spin.update()
-
-        self._click_decrement_arrow()
-        self.assertEqual(self.spin.get(), '1')
-
-    def test_values(self):
-        self.assertEqual(self.spin['values'],
-                         () if tcl_version < (8, 5) else '')
-        self.checkParam(self.spin, 'values', 'mon tue wed thur',
-                        expected=('mon', 'tue', 'wed', 'thur'))
-        self.checkParam(self.spin, 'values', ('mon', 'tue', 'wed', 'thur'))
-        self.checkParam(self.spin, 'values', (42, 3.14, '', 'any string'))
-        self.checkParam(
-            self.spin,
-            'values',
-            '',
-            expected='' if get_tk_patchlevel() < (8, 5, 10) else ()
-        )
-
-        self.spin['values'] = ['a', 1, 'c']
-
-        # test incrementing / decrementing values
-        self.spin.set('a')
-        self.spin.update()
-        self._click_increment_arrow()
-        self.assertEqual(self.spin.get(), '1')
-
-        self._click_decrement_arrow()
-        self.assertEqual(self.spin.get(), 'a')
-
-        # testing values with empty string set through configure
-        self.spin.configure(values=[1, '', 2])
-        self.assertEqual(self.spin['values'],
-                         ('1', '', '2') if self.wantobjects else
-                         '1 {} 2')
-
-        # testing values with spaces
-        self.spin['values'] = ['a b', 'a\tb', 'a\nb']
-        self.assertEqual(self.spin['values'],
-                         ('a b', 'a\tb', 'a\nb') if self.wantobjects else
-                         '{a b} {a\tb} {a\nb}')
-
-        # testing values with special characters
-        self.spin['values'] = [r'a\tb', '"a"', '} {']
-        self.assertEqual(self.spin['values'],
-                         (r'a\tb', '"a"', '} {') if self.wantobjects else
-                         r'a\\tb {"a"} \}\ \{')
-
-        # testing creating spinbox with empty string in values
-        spin2 = ttk.Spinbox(self.root, values=[1, 2, ''])
-        self.assertEqual(spin2['values'],
-                         ('1', '2', '') if self.wantobjects else '1 2 {}')
-        spin2.destroy()
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class TreeviewTest(AbstractWidgetTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'columns', 'cursor', 'displaycolumns',
-        'height', 'padding', 'selectmode', 'show',
-        'style', 'takefocus', 'xscrollcommand', 'yscrollcommand',
-    )
-
-    def setUp(self):
-        super().setUp()
-        self.tv = self.create(padding=0)
-
-    def create(self, **kwargs):
-        return ttk.Treeview(self.root, **kwargs)
-
-    def test_columns(self):
-        widget = self.create()
-        self.checkParam(widget, 'columns', 'a b c',
-                        expected=('a', 'b', 'c'))
-        self.checkParam(widget, 'columns', ('a', 'b', 'c'))
-        self.checkParam(widget, 'columns', (),
-                        expected='' if get_tk_patchlevel() < (8, 5, 10) else ())
-
-    def test_displaycolumns(self):
-        widget = self.create()
-        widget['columns'] = ('a', 'b', 'c')
-        self.checkParam(widget, 'displaycolumns', 'b a c',
-                        expected=('b', 'a', 'c'))
-        self.checkParam(widget, 'displaycolumns', ('b', 'a', 'c'))
-        self.checkParam(widget, 'displaycolumns', '#all',
-                        expected=('#all',))
-        self.checkParam(widget, 'displaycolumns', (2, 1, 0))
-        self.checkInvalidParam(widget, 'displaycolumns', ('a', 'b', 'd'),
-                               errmsg='Invalid column index d')
-        self.checkInvalidParam(widget, 'displaycolumns', (1, 2, 3),
-                               errmsg='Column index 3 out of bounds')
-        self.checkInvalidParam(widget, 'displaycolumns', (1, -2),
-                               errmsg='Column index -2 out of bounds')
-
-    def test_height(self):
-        widget = self.create()
-        self.checkPixelsParam(widget, 'height', 100, -100, 0, '3c', conv=False)
-        self.checkPixelsParam(widget, 'height', 101.2, 102.6, conv=noconv)
-
-    def test_selectmode(self):
-        widget = self.create()
-        self.checkEnumParam(widget, 'selectmode',
-                            'none', 'browse', 'extended')
-
-    def test_show(self):
-        widget = self.create()
-        self.checkParam(widget, 'show', 'tree headings',
-                        expected=('tree', 'headings'))
-        self.checkParam(widget, 'show', ('tree', 'headings'))
-        self.checkParam(widget, 'show', ('headings', 'tree'))
-        self.checkParam(widget, 'show', 'tree', expected=('tree',))
-        self.checkParam(widget, 'show', 'headings', expected=('headings',))
-
-    def test_bbox(self):
-        self.tv.pack()
-        self.assertEqual(self.tv.bbox(''), '')
-        self.tv.wait_visibility()
-        self.tv.update()
-
-        item_id = self.tv.insert('', 'end')
-        children = self.tv.get_children()
-        self.assertTrue(children)
-
-        bbox = self.tv.bbox(children[0])
-        self.assertIsBoundingBox(bbox)
-
-        # compare width in bboxes
-        self.tv['columns'] = ['test']
-        self.tv.column('test', width=50)
-        bbox_column0 = self.tv.bbox(children[0], 0)
-        root_width = self.tv.column('#0', width=None)
-        if not self.wantobjects:
-            root_width = int(root_width)
-        self.assertEqual(bbox_column0[0], bbox[0] + root_width)
-
-        # verify that bbox of a closed item is the empty string
-        child1 = self.tv.insert(item_id, 'end')
-        self.assertEqual(self.tv.bbox(child1), '')
-
-
-    def test_children(self):
-        # no children yet, should get an empty tuple
-        self.assertEqual(self.tv.get_children(), ())
-
-        item_id = self.tv.insert('', 'end')
-        self.assertIsInstance(self.tv.get_children(), tuple)
-        self.assertEqual(self.tv.get_children()[0], item_id)
-
-        # add item_id and child3 as children of child2
-        child2 = self.tv.insert('', 'end')
-        child3 = self.tv.insert('', 'end')
-        self.tv.set_children(child2, item_id, child3)
-        self.assertEqual(self.tv.get_children(child2), (item_id, child3))
-
-        # child3 has child2 as parent, thus trying to set child2 as a children
-        # of child3 should result in an error
-        self.assertRaises(tkinter.TclError,
-            self.tv.set_children, child3, child2)
-
-        # remove child2 children
-        self.tv.set_children(child2)
-        self.assertEqual(self.tv.get_children(child2), ())
-
-        # remove root's children
-        self.tv.set_children('')
-        self.assertEqual(self.tv.get_children(), ())
-
-
-    def test_column(self):
-        # return a dict with all options/values
-        self.assertIsInstance(self.tv.column('#0'), dict)
-        # return a single value of the given option
-        if self.wantobjects:
-            self.assertIsInstance(self.tv.column('#0', width=None), int)
-        # set a new value for an option
-        self.tv.column('#0', width=10)
-        # testing new way to get option value
-        self.assertEqual(self.tv.column('#0', 'width'),
-                         10 if self.wantobjects else '10')
-        self.assertEqual(self.tv.column('#0', width=None),
-                         10 if self.wantobjects else '10')
-        # check read-only option
-        self.assertRaises(tkinter.TclError, self.tv.column, '#0', id='X')
-
-        self.assertRaises(tkinter.TclError, self.tv.column, 'invalid')
-        invalid_kws = [
-            {'unknown_option': 'some value'},  {'stretch': 'wrong'},
-            {'anchor': 'wrong'}, {'width': 'wrong'}, {'minwidth': 'wrong'}
-        ]
-        for kw in invalid_kws:
-            self.assertRaises(tkinter.TclError, self.tv.column, '#0',
-                **kw)
-
-
-    def test_delete(self):
-        self.assertRaises(tkinter.TclError, self.tv.delete, '#0')
-
-        item_id = self.tv.insert('', 'end')
-        item2 = self.tv.insert(item_id, 'end')
-        self.assertEqual(self.tv.get_children(), (item_id, ))
-        self.assertEqual(self.tv.get_children(item_id), (item2, ))
-
-        self.tv.delete(item_id)
-        self.assertFalse(self.tv.get_children())
-
-        # reattach should fail
-        self.assertRaises(tkinter.TclError,
-            self.tv.reattach, item_id, '', 'end')
-
-        # test multiple item delete
-        item1 = self.tv.insert('', 'end')
-        item2 = self.tv.insert('', 'end')
-        self.assertEqual(self.tv.get_children(), (item1, item2))
-
-        self.tv.delete(item1, item2)
-        self.assertFalse(self.tv.get_children())
-
-
-    def test_detach_reattach(self):
-        item_id = self.tv.insert('', 'end')
-        item2 = self.tv.insert(item_id, 'end')
-
-        # calling detach without items is valid, although it does nothing
-        prev = self.tv.get_children()
-        self.tv.detach() # this should do nothing
-        self.assertEqual(prev, self.tv.get_children())
-
-        self.assertEqual(self.tv.get_children(), (item_id, ))
-        self.assertEqual(self.tv.get_children(item_id), (item2, ))
-
-        # detach item with children
-        self.tv.detach(item_id)
-        self.assertFalse(self.tv.get_children())
-
-        # reattach item with children
-        self.tv.reattach(item_id, '', 'end')
-        self.assertEqual(self.tv.get_children(), (item_id, ))
-        self.assertEqual(self.tv.get_children(item_id), (item2, ))
-
-        # move a children to the root
-        self.tv.move(item2, '', 'end')
-        self.assertEqual(self.tv.get_children(), (item_id, item2))
-        self.assertEqual(self.tv.get_children(item_id), ())
-
-        # bad values
-        self.assertRaises(tkinter.TclError,
-            self.tv.reattach, 'nonexistent', '', 'end')
-        self.assertRaises(tkinter.TclError,
-            self.tv.detach, 'nonexistent')
-        self.assertRaises(tkinter.TclError,
-            self.tv.reattach, item2, 'otherparent', 'end')
-        self.assertRaises(tkinter.TclError,
-            self.tv.reattach, item2, '', 'invalid')
-
-        # multiple detach
-        self.tv.detach(item_id, item2)
-        self.assertEqual(self.tv.get_children(), ())
-        self.assertEqual(self.tv.get_children(item_id), ())
-
-
-    def test_exists(self):
-        self.assertEqual(self.tv.exists('something'), False)
-        self.assertEqual(self.tv.exists(''), True)
-        self.assertEqual(self.tv.exists({}), False)
-
-        # the following will make a tk.call equivalent to
-        # tk.call(treeview, "exists") which should result in an error
-        # in the tcl interpreter since tk requires an item.
-        self.assertRaises(tkinter.TclError, self.tv.exists, None)
-
-
-    def test_focus(self):
-        # nothing is focused right now
-        self.assertEqual(self.tv.focus(), '')
-
-        item1 = self.tv.insert('', 'end')
-        self.tv.focus(item1)
-        self.assertEqual(self.tv.focus(), item1)
-
-        self.tv.delete(item1)
-        self.assertEqual(self.tv.focus(), '')
-
-        # try focusing inexistent item
-        self.assertRaises(tkinter.TclError, self.tv.focus, 'hi')
-
-
-    def test_heading(self):
-        # check a dict is returned
-        self.assertIsInstance(self.tv.heading('#0'), dict)
-
-        # check a value is returned
-        self.tv.heading('#0', text='hi')
-        self.assertEqual(self.tv.heading('#0', 'text'), 'hi')
-        self.assertEqual(self.tv.heading('#0', text=None), 'hi')
-
-        # invalid option
-        self.assertRaises(tkinter.TclError, self.tv.heading, '#0',
-            background=None)
-        # invalid value
-        self.assertRaises(tkinter.TclError, self.tv.heading, '#0',
-            anchor=1)
-
-    def test_heading_callback(self):
-        def simulate_heading_click(x, y):
-            simulate_mouse_click(self.tv, x, y)
-            self.tv.update()
-
-        success = [] # no success for now
-
-        self.tv.pack()
-        self.tv.wait_visibility()
-        self.tv.heading('#0', command=lambda: success.append(True))
-        self.tv.column('#0', width=100)
-        self.tv.update()
-
-        # assuming that the coords (5, 5) fall into heading #0
-        simulate_heading_click(5, 5)
-        if not success:
-            self.fail("The command associated to the treeview heading wasn't "
-                "invoked.")
-
-        success = []
-        commands = self.tv.master._tclCommands
-        self.tv.heading('#0', command=str(self.tv.heading('#0', command=None)))
-        self.assertEqual(commands, self.tv.master._tclCommands)
-        simulate_heading_click(5, 5)
-        if not success:
-            self.fail("The command associated to the treeview heading wasn't "
-                "invoked.")
-
-        # XXX The following raises an error in a tcl interpreter, but not in
-        # Python
-        #self.tv.heading('#0', command='I dont exist')
-        #simulate_heading_click(5, 5)
-
-
-    def test_index(self):
-        # item 'what' doesn't exist
-        self.assertRaises(tkinter.TclError, self.tv.index, 'what')
-
-        self.assertEqual(self.tv.index(''), 0)
-
-        item1 = self.tv.insert('', 'end')
-        item2 = self.tv.insert('', 'end')
-        c1 = self.tv.insert(item1, 'end')
-        c2 = self.tv.insert(item1, 'end')
-        self.assertEqual(self.tv.index(item1), 0)
-        self.assertEqual(self.tv.index(c1), 0)
-        self.assertEqual(self.tv.index(c2), 1)
-        self.assertEqual(self.tv.index(item2), 1)
-
-        self.tv.move(item2, '', 0)
-        self.assertEqual(self.tv.index(item2), 0)
-        self.assertEqual(self.tv.index(item1), 1)
-
-        # check that index still works even after its parent and siblings
-        # have been detached
-        self.tv.detach(item1)
-        self.assertEqual(self.tv.index(c2), 1)
-        self.tv.detach(c1)
-        self.assertEqual(self.tv.index(c2), 0)
-
-        # but it fails after item has been deleted
-        self.tv.delete(item1)
-        self.assertRaises(tkinter.TclError, self.tv.index, c2)
-
-
-    def test_insert_item(self):
-        # parent 'none' doesn't exist
-        self.assertRaises(tkinter.TclError, self.tv.insert, 'none', 'end')
-
-        # open values
-        self.assertRaises(tkinter.TclError, self.tv.insert, '', 'end',
-            open='')
-        self.assertRaises(tkinter.TclError, self.tv.insert, '', 'end',
-            open='please')
-        self.assertFalse(self.tv.delete(self.tv.insert('', 'end', open=True)))
-        self.assertFalse(self.tv.delete(self.tv.insert('', 'end', open=False)))
-
-        # invalid index
-        self.assertRaises(tkinter.TclError, self.tv.insert, '', 'middle')
-
-        # trying to duplicate item id is invalid
-        itemid = self.tv.insert('', 'end', 'first-item')
-        self.assertEqual(itemid, 'first-item')
-        self.assertRaises(tkinter.TclError, self.tv.insert, '', 'end',
-            'first-item')
-        self.assertRaises(tkinter.TclError, self.tv.insert, '', 'end',
-            MockTclObj('first-item'))
-
-        # unicode values
-        value = '\xe1ba'
-        item = self.tv.insert('', 'end', values=(value, ))
-        self.assertEqual(self.tv.item(item, 'values'),
-                         (value,) if self.wantobjects else value)
-        self.assertEqual(self.tv.item(item, values=None),
-                         (value,) if self.wantobjects else value)
-
-        self.tv.item(item, values=self.root.splitlist(self.tv.item(item, values=None)))
-        self.assertEqual(self.tv.item(item, values=None),
-                         (value,) if self.wantobjects else value)
-
-        self.assertIsInstance(self.tv.item(item), dict)
-
-        # erase item values
-        self.tv.item(item, values='')
-        self.assertFalse(self.tv.item(item, values=None))
-
-        # item tags
-        item = self.tv.insert('', 'end', tags=[1, 2, value])
-        self.assertEqual(self.tv.item(item, tags=None),
-                         ('1', '2', value) if self.wantobjects else
-                         '1 2 %s' % value)
-        self.tv.item(item, tags=[])
-        self.assertFalse(self.tv.item(item, tags=None))
-        self.tv.item(item, tags=(1, 2))
-        self.assertEqual(self.tv.item(item, tags=None),
-                         ('1', '2') if self.wantobjects else '1 2')
-
-        # values with spaces
-        item = self.tv.insert('', 'end', values=('a b c',
-            '%s %s' % (value, value)))
-        self.assertEqual(self.tv.item(item, values=None),
-            ('a b c', '%s %s' % (value, value)) if self.wantobjects else
-            '{a b c} {%s %s}' % (value, value))
-
-        # text
-        self.assertEqual(self.tv.item(
-            self.tv.insert('', 'end', text="Label here"), text=None),
-            "Label here")
-        self.assertEqual(self.tv.item(
-            self.tv.insert('', 'end', text=value), text=None),
-            value)
-
-        # test for values which are not None
-        itemid = self.tv.insert('', 'end', 0)
-        self.assertEqual(itemid, '0')
-        itemid = self.tv.insert('', 'end', 0.0)
-        self.assertEqual(itemid, '0.0')
-        # this is because False resolves to 0 and element with 0 iid is already present
-        self.assertRaises(tkinter.TclError, self.tv.insert, '', 'end', False)
-        self.assertRaises(tkinter.TclError, self.tv.insert, '', 'end', '')
-
-
-    def test_selection(self):
-        self.assertRaises(TypeError, self.tv.selection, 'spam')
-        # item 'none' doesn't exist
-        self.assertRaises(tkinter.TclError, self.tv.selection_set, 'none')
-        self.assertRaises(tkinter.TclError, self.tv.selection_add, 'none')
-        self.assertRaises(tkinter.TclError, self.tv.selection_remove, 'none')
-        self.assertRaises(tkinter.TclError, self.tv.selection_toggle, 'none')
-
-        item1 = self.tv.insert('', 'end')
-        item2 = self.tv.insert('', 'end')
-        c1 = self.tv.insert(item1, 'end')
-        c2 = self.tv.insert(item1, 'end')
-        c3 = self.tv.insert(item1, 'end')
-        self.assertEqual(self.tv.selection(), ())
-
-        self.tv.selection_set(c1, item2)
-        self.assertEqual(self.tv.selection(), (c1, item2))
-        self.tv.selection_set(c2)
-        self.assertEqual(self.tv.selection(), (c2,))
-
-        self.tv.selection_add(c1, item2)
-        self.assertEqual(self.tv.selection(), (c1, c2, item2))
-        self.tv.selection_add(item1)
-        self.assertEqual(self.tv.selection(), (item1, c1, c2, item2))
-        self.tv.selection_add()
-        self.assertEqual(self.tv.selection(), (item1, c1, c2, item2))
-
-        self.tv.selection_remove(item1, c3)
-        self.assertEqual(self.tv.selection(), (c1, c2, item2))
-        self.tv.selection_remove(c2)
-        self.assertEqual(self.tv.selection(), (c1, item2))
-        self.tv.selection_remove()
-        self.assertEqual(self.tv.selection(), (c1, item2))
-
-        self.tv.selection_toggle(c1, c3)
-        self.assertEqual(self.tv.selection(), (c3, item2))
-        self.tv.selection_toggle(item2)
-        self.assertEqual(self.tv.selection(), (c3,))
-        self.tv.selection_toggle()
-        self.assertEqual(self.tv.selection(), (c3,))
-
-        self.tv.insert('', 'end', id='with spaces')
-        self.tv.selection_set('with spaces')
-        self.assertEqual(self.tv.selection(), ('with spaces',))
-
-        self.tv.insert('', 'end', id='{brace')
-        self.tv.selection_set('{brace')
-        self.assertEqual(self.tv.selection(), ('{brace',))
-
-        self.tv.insert('', 'end', id='unicode\u20ac')
-        self.tv.selection_set('unicode\u20ac')
-        self.assertEqual(self.tv.selection(), ('unicode\u20ac',))
-
-        self.tv.insert('', 'end', id=b'bytes\xe2\x82\xac')
-        self.tv.selection_set(b'bytes\xe2\x82\xac')
-        self.assertEqual(self.tv.selection(), ('bytes\xe2\x82\xac',))
-
-        self.tv.selection_set()
-        self.assertEqual(self.tv.selection(), ())
-
-        # Old interface
-        self.tv.selection_set((c1, item2))
-        self.assertEqual(self.tv.selection(), (c1, item2))
-        self.tv.selection_add((c1, item1))
-        self.assertEqual(self.tv.selection(), (item1, c1, item2))
-        self.tv.selection_remove((item1, c3))
-        self.assertEqual(self.tv.selection(), (c1, item2))
-        self.tv.selection_toggle((c1, c3))
-        self.assertEqual(self.tv.selection(), (c3, item2))
-
-
-    def test_set(self):
-        self.tv['columns'] = ['A', 'B']
-        item = self.tv.insert('', 'end', values=['a', 'b'])
-        self.assertEqual(self.tv.set(item), {'A': 'a', 'B': 'b'})
-
-        self.tv.set(item, 'B', 'a')
-        self.assertEqual(self.tv.item(item, values=None),
-                         ('a', 'a') if self.wantobjects else 'a a')
-
-        self.tv['columns'] = ['B']
-        self.assertEqual(self.tv.set(item), {'B': 'a'})
-
-        self.tv.set(item, 'B', 'b')
-        self.assertEqual(self.tv.set(item, column='B'), 'b')
-        self.assertEqual(self.tv.item(item, values=None),
-                         ('b', 'a') if self.wantobjects else 'b a')
-
-        self.tv.set(item, 'B', 123)
-        self.assertEqual(self.tv.set(item, 'B'),
-                         123 if self.wantobjects else '123')
-        self.assertEqual(self.tv.item(item, values=None),
-                         (123, 'a') if self.wantobjects else '123 a')
-        self.assertEqual(self.tv.set(item),
-                         {'B': 123} if self.wantobjects else {'B': '123'})
-
-        # inexistent column
-        self.assertRaises(tkinter.TclError, self.tv.set, item, 'A')
-        self.assertRaises(tkinter.TclError, self.tv.set, item, 'A', 'b')
-
-        # inexistent item
-        self.assertRaises(tkinter.TclError, self.tv.set, 'notme')
-
-
-    def test_tag_bind(self):
-        events = []
-        item1 = self.tv.insert('', 'end', tags=['call'])
-        item2 = self.tv.insert('', 'end', tags=['call'])
-        self.tv.tag_bind('call', '<ButtonPress-1>',
-            lambda evt: events.append(1))
-        self.tv.tag_bind('call', '<ButtonRelease-1>',
-            lambda evt: events.append(2))
-
-        self.tv.pack()
-        self.tv.wait_visibility()
-        self.tv.update()
-
-        pos_y = set()
-        found = set()
-        for i in range(0, 100, 10):
-            if len(found) == 2: # item1 and item2 already found
-                break
-            item_id = self.tv.identify_row(i)
-            if item_id and item_id not in found:
-                pos_y.add(i)
-                found.add(item_id)
-
-        self.assertEqual(len(pos_y), 2) # item1 and item2 y pos
-        for y in pos_y:
-            simulate_mouse_click(self.tv, 0, y)
-
-        # by now there should be 4 things in the events list, since each
-        # item had a bind for two events that were simulated above
-        self.assertEqual(len(events), 4)
-        for evt in zip(events[::2], events[1::2]):
-            self.assertEqual(evt, (1, 2))
-
-
-    def test_tag_configure(self):
-        # Just testing parameter passing for now
-        self.assertRaises(TypeError, self.tv.tag_configure)
-        self.assertRaises(tkinter.TclError, self.tv.tag_configure,
-            'test', sky='blue')
-        self.tv.tag_configure('test', foreground='blue')
-        self.assertEqual(str(self.tv.tag_configure('test', 'foreground')),
-            'blue')
-        self.assertEqual(str(self.tv.tag_configure('test', foreground=None)),
-            'blue')
-        self.assertIsInstance(self.tv.tag_configure('test'), dict)
-
-    def test_tag_has(self):
-        item1 = self.tv.insert('', 'end', text='Item 1', tags=['tag1'])
-        item2 = self.tv.insert('', 'end', text='Item 2', tags=['tag2'])
-        self.assertRaises(TypeError, self.tv.tag_has)
-        self.assertRaises(TclError, self.tv.tag_has, 'tag1', 'non-existing')
-        self.assertTrue(self.tv.tag_has('tag1', item1))
-        self.assertFalse(self.tv.tag_has('tag1', item2))
-        self.assertFalse(self.tv.tag_has('tag2', item1))
-        self.assertTrue(self.tv.tag_has('tag2', item2))
-        self.assertFalse(self.tv.tag_has('tag3', item1))
-        self.assertFalse(self.tv.tag_has('tag3', item2))
-        self.assertEqual(self.tv.tag_has('tag1'), (item1,))
-        self.assertEqual(self.tv.tag_has('tag2'), (item2,))
-        self.assertEqual(self.tv.tag_has('tag3'), ())
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class SeparatorTest(AbstractWidgetTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'cursor', 'orient', 'style', 'takefocus',
-        # 'state'?
-    )
-    default_orient = 'horizontal'
-
-    def create(self, **kwargs):
-        return ttk.Separator(self.root, **kwargs)
-
-
-@add_standard_options(StandardTtkOptionsTests)
-class SizegripTest(AbstractWidgetTest, unittest.TestCase):
-    OPTIONS = (
-        'class', 'cursor', 'style', 'takefocus',
-        # 'state'?
-    )
-
-    def create(self, **kwargs):
-        return ttk.Sizegrip(self.root, **kwargs)
-
-tests_gui = (
-        ButtonTest, CheckbuttonTest, ComboboxTest, EntryTest,
-        FrameTest, LabelFrameTest, LabelTest, MenubuttonTest,
-        NotebookTest, PanedWindowTest, ProgressbarTest,
-        RadiobuttonTest, ScaleTest, ScrollbarTest, SeparatorTest,
-        SizegripTest, SpinboxTest, TreeviewTest, WidgetTest,
-        )
-
-if __name__ == "__main__":
-    unittest.main()
diff --git Lib/tkinter/ttk.py Lib/tkinter/ttk.py
deleted file mode 100644
index 573544dd84a3..000000000000
--- Lib/tkinter/ttk.py
+++ /dev/null
@@ -1,1660 +0,0 @@
-"""Ttk wrapper.
-
-This module provides classes to allow using Tk themed widget set.
-
-Ttk is based on a revised and enhanced version of
-TIP #48 (http://tip.tcl.tk/48) specified style engine.
-
-Its basic idea is to separate, to the extent possible, the code
-implementing a widget's behavior from the code implementing its
-appearance. Widget class bindings are primarily responsible for
-maintaining the widget state and invoking callbacks, all aspects
-of the widgets appearance lies at Themes.
-"""
-
-__version__ = "0.3.1"
-
-__author__ = "Guilherme Polo <ggpolo@gmail.com>"
-
-__all__ = ["Button", "Checkbutton", "Combobox", "Entry", "Frame", "Label",
-           "Labelframe", "LabelFrame", "Menubutton", "Notebook", "Panedwindow",
-           "PanedWindow", "Progressbar", "Radiobutton", "Scale", "Scrollbar",
-           "Separator", "Sizegrip", "Spinbox", "Style", "Treeview",
-           # Extensions
-           "LabeledScale", "OptionMenu",
-           # functions
-           "tclobjs_to_py", "setup_master"]
-
-import tkinter
-from tkinter import _flatten, _join, _stringify, _splitdict
-
-# Verify if Tk is new enough to not need the Tile package
-_REQUIRE_TILE = True if tkinter.TkVersion < 8.5 else False
-
-def _load_tile(master):
-    if _REQUIRE_TILE:
-        import os
-        tilelib = os.environ.get('TILE_LIBRARY')
-        if tilelib:
-            # append custom tile path to the list of directories that
-            # Tcl uses when attempting to resolve packages with the package
-            # command
-            master.tk.eval(
-                    'global auto_path; '
-                    'lappend auto_path {%s}' % tilelib)
-
-        master.tk.eval('package require tile') # TclError may be raised here
-        master._tile_loaded = True
-
-def _format_optvalue(value, script=False):
-    """Internal function."""
-    if script:
-        # if caller passes a Tcl script to tk.call, all the values need to
-        # be grouped into words (arguments to a command in Tcl dialect)
-        value = _stringify(value)
-    elif isinstance(value, (list, tuple)):
-        value = _join(value)
-    return value
-
-def _format_optdict(optdict, script=False, ignore=None):
-    """Formats optdict to a tuple to pass it to tk.call.
-
-    E.g. (script=False):
-      {'foreground': 'blue', 'padding': [1, 2, 3, 4]} returns:
-      ('-foreground', 'blue', '-padding', '1 2 3 4')"""
-
-    opts = []
-    for opt, value in optdict.items():
-        if not ignore or opt not in ignore:
-            opts.append("-%s" % opt)
-            if value is not None:
-                opts.append(_format_optvalue(value, script))
-
-    return _flatten(opts)
-
-def _mapdict_values(items):
-    # each value in mapdict is expected to be a sequence, where each item
-    # is another sequence containing a state (or several) and a value
-    # E.g. (script=False):
-    #   [('active', 'selected', 'grey'), ('focus', [1, 2, 3, 4])]
-    #   returns:
-    #   ['active selected', 'grey', 'focus', [1, 2, 3, 4]]
-    opt_val = []
-    for *state, val in items:
-        # hacks for backward compatibility
-        state[0] # raise IndexError if empty
-        if len(state) == 1:
-            # if it is empty (something that evaluates to False), then
-            # format it to Tcl code to denote the "normal" state
-            state = state[0] or ''
-        else:
-            # group multiple states
-            state = ' '.join(state) # raise TypeError if not str
-        opt_val.append(state)
-        if val is not None:
-            opt_val.append(val)
-    return opt_val
-
-def _format_mapdict(mapdict, script=False):
-    """Formats mapdict to pass it to tk.call.
-
-    E.g. (script=False):
-      {'expand': [('active', 'selected', 'grey'), ('focus', [1, 2, 3, 4])]}
-
-      returns:
-
-      ('-expand', '{active selected} grey focus {1, 2, 3, 4}')"""
-
-    opts = []
-    for opt, value in mapdict.items():
-        opts.extend(("-%s" % opt,
-                     _format_optvalue(_mapdict_values(value), script)))
-
-    return _flatten(opts)
-
-def _format_elemcreate(etype, script=False, *args, **kw):
-    """Formats args and kw according to the given element factory etype."""
-    spec = None
-    opts = ()
-    if etype in ("image", "vsapi"):
-        if etype == "image": # define an element based on an image
-            # first arg should be the default image name
-            iname = args[0]
-            # next args, if any, are statespec/value pairs which is almost
-            # a mapdict, but we just need the value
-            imagespec = _join(_mapdict_values(args[1:]))
-            spec = "%s %s" % (iname, imagespec)
-
-        else:
-            # define an element whose visual appearance is drawn using the
-            # Microsoft Visual Styles API which is responsible for the
-            # themed styles on Windows XP and Vista.
-            # Availability: Tk 8.6, Windows XP and Vista.
-            class_name, part_id = args[:2]
-            statemap = _join(_mapdict_values(args[2:]))
-            spec = "%s %s %s" % (class_name, part_id, statemap)
-
-        opts = _format_optdict(kw, script)
-
-    elif etype == "from": # clone an element
-        # it expects a themename and optionally an element to clone from,
-        # otherwise it will clone {} (empty element)
-        spec = args[0] # theme name
-        if len(args) > 1: # elementfrom specified
-            opts = (_format_optvalue(args[1], script),)
-
-    if script:
-        spec = '{%s}' % spec
-        opts = ' '.join(opts)
-
-    return spec, opts
-
-def _format_layoutlist(layout, indent=0, indent_size=2):
-    """Formats a layout list so we can pass the result to ttk::style
-    layout and ttk::style settings. Note that the layout doesn't have to
-    be a list necessarily.
-
-    E.g.:
-      [("Menubutton.background", None),
-       ("Menubutton.button", {"children":
-           [("Menubutton.focus", {"children":
-               [("Menubutton.padding", {"children":
-                [("Menubutton.label", {"side": "left", "expand": 1})]
-               })]
-           })]
-       }),
-       ("Menubutton.indicator", {"side": "right"})
-      ]
-
-      returns:
-
-      Menubutton.background
-      Menubutton.button -children {
-        Menubutton.focus -children {
-          Menubutton.padding -children {
-            Menubutton.label -side left -expand 1
-          }
-        }
-      }
-      Menubutton.indicator -side right"""
-    script = []
-
-    for layout_elem in layout:
-        elem, opts = layout_elem
-        opts = opts or {}
-        fopts = ' '.join(_format_optdict(opts, True, ("children",)))
-        head = "%s%s%s" % (' ' * indent, elem, (" %s" % fopts) if fopts else '')
-
-        if "children" in opts:
-            script.append(head + " -children {")
-            indent += indent_size
-            newscript, indent = _format_layoutlist(opts['children'], indent,
-                indent_size)
-            script.append(newscript)
-            indent -= indent_size
-            script.append('%s}' % (' ' * indent))
-        else:
-            script.append(head)
-
-    return '\n'.join(script), indent
-
-def _script_from_settings(settings):
-    """Returns an appropriate script, based on settings, according to
-    theme_settings definition to be used by theme_settings and
-    theme_create."""
-    script = []
-    # a script will be generated according to settings passed, which
-    # will then be evaluated by Tcl
-    for name, opts in settings.items():
-        # will format specific keys according to Tcl code
-        if opts.get('configure'): # format 'configure'
-            s = ' '.join(_format_optdict(opts['configure'], True))
-            script.append("ttk::style configure %s %s;" % (name, s))
-
-        if opts.get('map'): # format 'map'
-            s = ' '.join(_format_mapdict(opts['map'], True))
-            script.append("ttk::style map %s %s;" % (name, s))
-
-        if 'layout' in opts: # format 'layout' which may be empty
-            if not opts['layout']:
-                s = 'null' # could be any other word, but this one makes sense
-            else:
-                s, _ = _format_layoutlist(opts['layout'])
-            script.append("ttk::style layout %s {\n%s\n}" % (name, s))
-
-        if opts.get('element create'): # format 'element create'
-            eopts = opts['element create']
-            etype = eopts[0]
-
-            # find where args end, and where kwargs start
-            argc = 1 # etype was the first one
-            while argc < len(eopts) and not hasattr(eopts[argc], 'items'):
-                argc += 1
-
-            elemargs = eopts[1:argc]
-            elemkw = eopts[argc] if argc < len(eopts) and eopts[argc] else {}
-            spec, opts = _format_elemcreate(etype, True, *elemargs, **elemkw)
-
-            script.append("ttk::style element create %s %s %s %s" % (
-                name, etype, spec, opts))
-
-    return '\n'.join(script)
-
-def _list_from_statespec(stuple):
-    """Construct a list from the given statespec tuple according to the
-    accepted statespec accepted by _format_mapdict."""
-    nval = []
-    for val in stuple:
-        typename = getattr(val, 'typename', None)
-        if typename is None:
-            nval.append(val)
-        else: # this is a Tcl object
-            val = str(val)
-            if typename == 'StateSpec':
-                val = val.split()
-            nval.append(val)
-
-    it = iter(nval)
-    return [_flatten(spec) for spec in zip(it, it)]
-
-def _list_from_layouttuple(tk, ltuple):
-    """Construct a list from the tuple returned by ttk::layout, this is
-    somewhat the reverse of _format_layoutlist."""
-    ltuple = tk.splitlist(ltuple)
-    res = []
-
-    indx = 0
-    while indx < len(ltuple):
-        name = ltuple[indx]
-        opts = {}
-        res.append((name, opts))
-        indx += 1
-
-        while indx < len(ltuple): # grab name's options
-            opt, val = ltuple[indx:indx + 2]
-            if not opt.startswith('-'): # found next name
-                break
-
-            opt = opt[1:] # remove the '-' from the option
-            indx += 2
-
-            if opt == 'children':
-                val = _list_from_layouttuple(tk, val)
-
-            opts[opt] = val
-
-    return res
-
-def _val_or_dict(tk, options, *args):
-    """Format options then call Tk command with args and options and return
-    the appropriate result.
-
-    If no option is specified, a dict is returned. If an option is
-    specified with the None value, the value for that option is returned.
-    Otherwise, the function just sets the passed options and the caller
-    shouldn't be expecting a return value anyway."""
-    options = _format_optdict(options)
-    res = tk.call(*(args + options))
-
-    if len(options) % 2: # option specified without a value, return its value
-        return res
-
-    return _splitdict(tk, res, conv=_tclobj_to_py)
-
-def _convert_stringval(value):
-    """Converts a value to, hopefully, a more appropriate Python object."""
-    value = str(value)
-    try:
-        value = int(value)
-    except (ValueError, TypeError):
-        pass
-
-    return value
-
-def _to_number(x):
-    if isinstance(x, str):
-        if '.' in x:
-            x = float(x)
-        else:
-            x = int(x)
-    return x
-
-def _tclobj_to_py(val):
-    """Return value converted from Tcl object to Python object."""
-    if val and hasattr(val, '__len__') and not isinstance(val, str):
-        if getattr(val[0], 'typename', None) == 'StateSpec':
-            val = _list_from_statespec(val)
-        else:
-            val = list(map(_convert_stringval, val))
-
-    elif hasattr(val, 'typename'): # some other (single) Tcl object
-        val = _convert_stringval(val)
-
-    return val
-
-def tclobjs_to_py(adict):
-    """Returns adict with its values converted from Tcl objects to Python
-    objects."""
-    for opt, val in adict.items():
-        adict[opt] = _tclobj_to_py(val)
-
-    return adict
-
-def setup_master(master=None):
-    """If master is not None, itself is returned. If master is None,
-    the default master is returned if there is one, otherwise a new
-    master is created and returned.
-
-    If it is not allowed to use the default root and master is None,
-    RuntimeError is raised."""
-    if master is None:
-        if tkinter._support_default_root:
-            master = tkinter._default_root or tkinter.Tk()
-        else:
-            raise RuntimeError(
-                    "No master specified and tkinter is "
-                    "configured to not support default root")
-    return master
-
-
-class Style(object):
-    """Manipulate style database."""
-
-    _name = "ttk::style"
-
-    def __init__(self, master=None):
-        master = setup_master(master)
-
-        if not getattr(master, '_tile_loaded', False):
-            # Load tile now, if needed
-            _load_tile(master)
-
-        self.master = master
-        self.tk = self.master.tk
-
-
-    def configure(self, style, query_opt=None, **kw):
-        """Query or sets the default value of the specified option(s) in
-        style.
-
-        Each key in kw is an option and each value is either a string or
-        a sequence identifying the value for that option."""
-        if query_opt is not None:
-            kw[query_opt] = None
-        result = _val_or_dict(self.tk, kw, self._name, "configure", style)
-        if result or query_opt:
-            return result
-
-
-    def map(self, style, query_opt=None, **kw):
-        """Query or sets dynamic values of the specified option(s) in
-        style.
-
-        Each key in kw is an option and each value should be a list or a
-        tuple (usually) containing statespecs grouped in tuples, or list,
-        or something else of your preference. A statespec is compound of
-        one or more states and then a value."""
-        if query_opt is not None:
-            return _list_from_statespec(self.tk.splitlist(
-                self.tk.call(self._name, "map", style, '-%s' % query_opt)))
-
-        return _splitdict(
-            self.tk,
-            self.tk.call(self._name, "map", style, *_format_mapdict(kw)),
-            conv=_tclobj_to_py)
-
-
-    def lookup(self, style, option, state=None, default=None):
-        """Returns the value specified for option in style.
-
-        If state is specified it is expected to be a sequence of one
-        or more states. If the default argument is set, it is used as
-        a fallback value in case no specification for option is found."""
-        state = ' '.join(state) if state else ''
-
-        return self.tk.call(self._name, "lookup", style, '-%s' % option,
-            state, default)
-
-
-    def layout(self, style, layoutspec=None):
-        """Define the widget layout for given style. If layoutspec is
-        omitted, return the layout specification for given style.
-
-        layoutspec is expected to be a list or an object different than
-        None that evaluates to False if you want to "turn off" that style.
-        If it is a list (or tuple, or something else), each item should be
-        a tuple where the first item is the layout name and the second item
-        should have the format described below:
-
-        LAYOUTS
-
-            A layout can contain the value None, if takes no options, or
-            a dict of options specifying how to arrange the element.
-            The layout mechanism uses a simplified version of the pack
-            geometry manager: given an initial cavity, each element is
-            allocated a parcel. Valid options/values are:
-
-                side: whichside
-                    Specifies which side of the cavity to place the
-                    element; one of top, right, bottom or left. If
-                    omitted, the element occupies the entire cavity.
-
-                sticky: nswe
-                    Specifies where the element is placed inside its
-                    allocated parcel.
-
-                children: [sublayout... ]
-                    Specifies a list of elements to place inside the
-                    element. Each element is a tuple (or other sequence)
-                    where the first item is the layout name, and the other
-                    is a LAYOUT."""
-        lspec = None
-        if layoutspec:
-            lspec = _format_layoutlist(layoutspec)[0]
-        elif layoutspec is not None: # will disable the layout ({}, '', etc)
-            lspec = "null" # could be any other word, but this may make sense
-                           # when calling layout(style) later
-
-        return _list_from_layouttuple(self.tk,
-            self.tk.call(self._name, "layout", style, lspec))
-
-
-    def element_create(self, elementname, etype, *args, **kw):
-        """Create a new element in the current theme of given etype."""
-        spec, opts = _format_elemcreate(etype, False, *args, **kw)
-        self.tk.call(self._name, "element", "create", elementname, etype,
-            spec, *opts)
-
-
-    def element_names(self):
-        """Returns the list of elements defined in the current theme."""
-        return tuple(n.lstrip('-') for n in self.tk.splitlist(
-            self.tk.call(self._name, "element", "names")))
-
-
-    def element_options(self, elementname):
-        """Return the list of elementname's options."""
-        return tuple(o.lstrip('-') for o in self.tk.splitlist(
-            self.tk.call(self._name, "element", "options", elementname)))
-
-
-    def theme_create(self, themename, parent=None, settings=None):
-        """Creates a new theme.
-
-        It is an error if themename already exists. If parent is
-        specified, the new theme will inherit styles, elements and
-        layouts from the specified parent theme. If settings are present,
-        they are expected to have the same syntax used for theme_settings."""
-        script = _script_from_settings(settings) if settings else ''
-
-        if parent:
-            self.tk.call(self._name, "theme", "create", themename,
-                "-parent", parent, "-settings", script)
-        else:
-            self.tk.call(self._name, "theme", "create", themename,
-                "-settings", script)
-
-
-    def theme_settings(self, themename, settings):
-        """Temporarily sets the current theme to themename, apply specified
-        settings and then restore the previous theme.
-
-        Each key in settings is a style and each value may contain the
-        keys 'configure', 'map', 'layout' and 'element create' and they
-        are expected to have the same format as specified by the methods
-        configure, map, layout and element_create respectively."""
-        script = _script_from_settings(settings)
-        self.tk.call(self._name, "theme", "settings", themename, script)
-
-
-    def theme_names(self):
-        """Returns a list of all known themes."""
-        return self.tk.splitlist(self.tk.call(self._name, "theme", "names"))
-
-
-    def theme_use(self, themename=None):
-        """If themename is None, returns the theme in use, otherwise, set
-        the current theme to themename, refreshes all widgets and emits
-        a <<ThemeChanged>> event."""
-        if themename is None:
-            # Starting on Tk 8.6, checking this global is no longer needed
-            # since it allows doing self.tk.call(self._name, "theme", "use")
-            return self.tk.eval("return $ttk::currentTheme")
-
-        # using "ttk::setTheme" instead of "ttk::style theme use" causes
-        # the variable currentTheme to be updated, also, ttk::setTheme calls
-        # "ttk::style theme use" in order to change theme.
-        self.tk.call("ttk::setTheme", themename)
-
-
-class Widget(tkinter.Widget):
-    """Base class for Tk themed widgets."""
-
-    def __init__(self, master, widgetname, kw=None):
-        """Constructs a Ttk Widget with the parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, takefocus, style
-
-        SCROLLABLE WIDGET OPTIONS
-
-            xscrollcommand, yscrollcommand
-
-        LABEL WIDGET OPTIONS
-
-            text, textvariable, underline, image, compound, width
-
-        WIDGET STATES
-
-            active, disabled, focus, pressed, selected, background,
-            readonly, alternate, invalid
-        """
-        master = setup_master(master)
-        if not getattr(master, '_tile_loaded', False):
-            # Load tile now, if needed
-            _load_tile(master)
-        tkinter.Widget.__init__(self, master, widgetname, kw=kw)
-
-
-    def identify(self, x, y):
-        """Returns the name of the element at position x, y, or the empty
-        string if the point does not lie within any element.
-
-        x and y are pixel coordinates relative to the widget."""
-        return self.tk.call(self._w, "identify", x, y)
-
-
-    def instate(self, statespec, callback=None, *args, **kw):
-        """Test the widget's state.
-
-        If callback is not specified, returns True if the widget state
-        matches statespec and False otherwise. If callback is specified,
-        then it will be invoked with *args, **kw if the widget state
-        matches statespec. statespec is expected to be a sequence."""
-        ret = self.tk.getboolean(
-                self.tk.call(self._w, "instate", ' '.join(statespec)))
-        if ret and callback:
-            return callback(*args, **kw)
-
-        return ret
-
-
-    def state(self, statespec=None):
-        """Modify or inquire widget state.
-
-        Widget state is returned if statespec is None, otherwise it is
-        set according to the statespec flags and then a new state spec
-        is returned indicating which flags were changed. statespec is
-        expected to be a sequence."""
-        if statespec is not None:
-            statespec = ' '.join(statespec)
-
-        return self.tk.splitlist(str(self.tk.call(self._w, "state", statespec)))
-
-
-class Button(Widget):
-    """Ttk Button widget, displays a textual label and/or image, and
-    evaluates a command when pressed."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Button widget with the parent master.
-
-        STANDARD OPTIONS
-
-            class, compound, cursor, image, state, style, takefocus,
-            text, textvariable, underline, width
-
-        WIDGET-SPECIFIC OPTIONS
-
-            command, default, width
-        """
-        Widget.__init__(self, master, "ttk::button", kw)
-
-
-    def invoke(self):
-        """Invokes the command associated with the button."""
-        return self.tk.call(self._w, "invoke")
-
-
-class Checkbutton(Widget):
-    """Ttk Checkbutton widget which is either in on- or off-state."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Checkbutton widget with the parent master.
-
-        STANDARD OPTIONS
-
-            class, compound, cursor, image, state, style, takefocus,
-            text, textvariable, underline, width
-
-        WIDGET-SPECIFIC OPTIONS
-
-            command, offvalue, onvalue, variable
-        """
-        Widget.__init__(self, master, "ttk::checkbutton", kw)
-
-
-    def invoke(self):
-        """Toggles between the selected and deselected states and
-        invokes the associated command. If the widget is currently
-        selected, sets the option variable to the offvalue option
-        and deselects the widget; otherwise, sets the option variable
-        to the option onvalue.
-
-        Returns the result of the associated command."""
-        return self.tk.call(self._w, "invoke")
-
-
-class Entry(Widget, tkinter.Entry):
-    """Ttk Entry widget displays a one-line text string and allows that
-    string to be edited by the user."""
-
-    def __init__(self, master=None, widget=None, **kw):
-        """Constructs a Ttk Entry widget with the parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus, xscrollcommand
-
-        WIDGET-SPECIFIC OPTIONS
-
-            exportselection, invalidcommand, justify, show, state,
-            textvariable, validate, validatecommand, width
-
-        VALIDATION MODES
-
-            none, key, focus, focusin, focusout, all
-        """
-        Widget.__init__(self, master, widget or "ttk::entry", kw)
-
-
-    def bbox(self, index):
-        """Return a tuple of (x, y, width, height) which describes the
-        bounding box of the character given by index."""
-        return self._getints(self.tk.call(self._w, "bbox", index))
-
-
-    def identify(self, x, y):
-        """Returns the name of the element at position x, y, or the
-        empty string if the coordinates are outside the window."""
-        return self.tk.call(self._w, "identify", x, y)
-
-
-    def validate(self):
-        """Force revalidation, independent of the conditions specified
-        by the validate option. Returns False if validation fails, True
-        if it succeeds. Sets or clears the invalid state accordingly."""
-        return self.tk.getboolean(self.tk.call(self._w, "validate"))
-
-
-class Combobox(Entry):
-    """Ttk Combobox widget combines a text field with a pop-down list of
-    values."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Combobox widget with the parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus
-
-        WIDGET-SPECIFIC OPTIONS
-
-            exportselection, justify, height, postcommand, state,
-            textvariable, values, width
-        """
-        Entry.__init__(self, master, "ttk::combobox", **kw)
-
-
-    def current(self, newindex=None):
-        """If newindex is supplied, sets the combobox value to the
-        element at position newindex in the list of values. Otherwise,
-        returns the index of the current value in the list of values
-        or -1 if the current value does not appear in the list."""
-        if newindex is None:
-            return self.tk.getint(self.tk.call(self._w, "current"))
-        return self.tk.call(self._w, "current", newindex)
-
-
-    def set(self, value):
-        """Sets the value of the combobox to value."""
-        self.tk.call(self._w, "set", value)
-
-
-class Frame(Widget):
-    """Ttk Frame widget is a container, used to group other widgets
-    together."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Frame with parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus
-
-        WIDGET-SPECIFIC OPTIONS
-
-            borderwidth, relief, padding, width, height
-        """
-        Widget.__init__(self, master, "ttk::frame", kw)
-
-
-class Label(Widget):
-    """Ttk Label widget displays a textual label and/or image."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Label with parent master.
-
-        STANDARD OPTIONS
-
-            class, compound, cursor, image, style, takefocus, text,
-            textvariable, underline, width
-
-        WIDGET-SPECIFIC OPTIONS
-
-            anchor, background, font, foreground, justify, padding,
-            relief, text, wraplength
-        """
-        Widget.__init__(self, master, "ttk::label", kw)
-
-
-class Labelframe(Widget):
-    """Ttk Labelframe widget is a container used to group other widgets
-    together. It has an optional label, which may be a plain text string
-    or another widget."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Labelframe with parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus
-
-        WIDGET-SPECIFIC OPTIONS
-            labelanchor, text, underline, padding, labelwidget, width,
-            height
-        """
-        Widget.__init__(self, master, "ttk::labelframe", kw)
-
-LabelFrame = Labelframe # tkinter name compatibility
-
-
-class Menubutton(Widget):
-    """Ttk Menubutton widget displays a textual label and/or image, and
-    displays a menu when pressed."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Menubutton with parent master.
-
-        STANDARD OPTIONS
-
-            class, compound, cursor, image, state, style, takefocus,
-            text, textvariable, underline, width
-
-        WIDGET-SPECIFIC OPTIONS
-
-            direction, menu
-        """
-        Widget.__init__(self, master, "ttk::menubutton", kw)
-
-
-class Notebook(Widget):
-    """Ttk Notebook widget manages a collection of windows and displays
-    a single one at a time. Each child window is associated with a tab,
-    which the user may select to change the currently-displayed window."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Notebook with parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus
-
-        WIDGET-SPECIFIC OPTIONS
-
-            height, padding, width
-
-        TAB OPTIONS
-
-            state, sticky, padding, text, image, compound, underline
-
-        TAB IDENTIFIERS (tab_id)
-
-            The tab_id argument found in several methods may take any of
-            the following forms:
-
-                * An integer between zero and the number of tabs
-                * The name of a child window
-                * A positional specification of the form "@x,y", which
-                  defines the tab
-                * The string "current", which identifies the
-                  currently-selected tab
-                * The string "end", which returns the number of tabs (only
-                  valid for method index)
-        """
-        Widget.__init__(self, master, "ttk::notebook", kw)
-
-
-    def add(self, child, **kw):
-        """Adds a new tab to the notebook.
-
-        If window is currently managed by the notebook but hidden, it is
-        restored to its previous position."""
-        self.tk.call(self._w, "add", child, *(_format_optdict(kw)))
-
-
-    def forget(self, tab_id):
-        """Removes the tab specified by tab_id, unmaps and unmanages the
-        associated window."""
-        self.tk.call(self._w, "forget", tab_id)
-
-
-    def hide(self, tab_id):
-        """Hides the tab specified by tab_id.
-
-        The tab will not be displayed, but the associated window remains
-        managed by the notebook and its configuration remembered. Hidden
-        tabs may be restored with the add command."""
-        self.tk.call(self._w, "hide", tab_id)
-
-
-    def identify(self, x, y):
-        """Returns the name of the tab element at position x, y, or the
-        empty string if none."""
-        return self.tk.call(self._w, "identify", x, y)
-
-
-    def index(self, tab_id):
-        """Returns the numeric index of the tab specified by tab_id, or
-        the total number of tabs if tab_id is the string "end"."""
-        return self.tk.getint(self.tk.call(self._w, "index", tab_id))
-
-
-    def insert(self, pos, child, **kw):
-        """Inserts a pane at the specified position.
-
-        pos is either the string end, an integer index, or the name of
-        a managed child. If child is already managed by the notebook,
-        moves it to the specified position."""
-        self.tk.call(self._w, "insert", pos, child, *(_format_optdict(kw)))
-
-
-    def select(self, tab_id=None):
-        """Selects the specified tab.
-
-        The associated child window will be displayed, and the
-        previously-selected window (if different) is unmapped. If tab_id
-        is omitted, returns the widget name of the currently selected
-        pane."""
-        return self.tk.call(self._w, "select", tab_id)
-
-
-    def tab(self, tab_id, option=None, **kw):
-        """Query or modify the options of the specific tab_id.
-
-        If kw is not given, returns a dict of the tab option values. If option
-        is specified, returns the value of that option. Otherwise, sets the
-        options to the corresponding values."""
-        if option is not None:
-            kw[option] = None
-        return _val_or_dict(self.tk, kw, self._w, "tab", tab_id)
-
-
-    def tabs(self):
-        """Returns a list of windows managed by the notebook."""
-        return self.tk.splitlist(self.tk.call(self._w, "tabs") or ())
-
-
-    def enable_traversal(self):
-        """Enable keyboard traversal for a toplevel window containing
-        this notebook.
-
-        This will extend the bindings for the toplevel window containing
-        this notebook as follows:
-
-            Control-Tab: selects the tab following the currently selected
-                         one
-
-            Shift-Control-Tab: selects the tab preceding the currently
-                               selected one
-
-            Alt-K: where K is the mnemonic (underlined) character of any
-                   tab, will select that tab.
-
-        Multiple notebooks in a single toplevel may be enabled for
-        traversal, including nested notebooks. However, notebook traversal
-        only works properly if all panes are direct children of the
-        notebook."""
-        # The only, and good, difference I see is about mnemonics, which works
-        # after calling this method. Control-Tab and Shift-Control-Tab always
-        # works (here at least).
-        self.tk.call("ttk::notebook::enableTraversal", self._w)
-
-
-class Panedwindow(Widget, tkinter.PanedWindow):
-    """Ttk Panedwindow widget displays a number of subwindows, stacked
-    either vertically or horizontally."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Panedwindow with parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus
-
-        WIDGET-SPECIFIC OPTIONS
-
-            orient, width, height
-
-        PANE OPTIONS
-
-            weight
-        """
-        Widget.__init__(self, master, "ttk::panedwindow", kw)
-
-
-    forget = tkinter.PanedWindow.forget # overrides Pack.forget
-
-
-    def insert(self, pos, child, **kw):
-        """Inserts a pane at the specified positions.
-
-        pos is either the string end, and integer index, or the name
-        of a child. If child is already managed by the paned window,
-        moves it to the specified position."""
-        self.tk.call(self._w, "insert", pos, child, *(_format_optdict(kw)))
-
-
-    def pane(self, pane, option=None, **kw):
-        """Query or modify the options of the specified pane.
-
-        pane is either an integer index or the name of a managed subwindow.
-        If kw is not given, returns a dict of the pane option values. If
-        option is specified then the value for that option is returned.
-        Otherwise, sets the options to the corresponding values."""
-        if option is not None:
-            kw[option] = None
-        return _val_or_dict(self.tk, kw, self._w, "pane", pane)
-
-
-    def sashpos(self, index, newpos=None):
-        """If newpos is specified, sets the position of sash number index.
-
-        May adjust the positions of adjacent sashes to ensure that
-        positions are monotonically increasing. Sash positions are further
-        constrained to be between 0 and the total size of the widget.
-
-        Returns the new position of sash number index."""
-        return self.tk.getint(self.tk.call(self._w, "sashpos", index, newpos))
-
-PanedWindow = Panedwindow # tkinter name compatibility
-
-
-class Progressbar(Widget):
-    """Ttk Progressbar widget shows the status of a long-running
-    operation. They can operate in two modes: determinate mode shows the
-    amount completed relative to the total amount of work to be done, and
-    indeterminate mode provides an animated display to let the user know
-    that something is happening."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Progressbar with parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus
-
-        WIDGET-SPECIFIC OPTIONS
-
-            orient, length, mode, maximum, value, variable, phase
-        """
-        Widget.__init__(self, master, "ttk::progressbar", kw)
-
-
-    def start(self, interval=None):
-        """Begin autoincrement mode: schedules a recurring timer event
-        that calls method step every interval milliseconds.
-
-        interval defaults to 50 milliseconds (20 steps/second) if omitted."""
-        self.tk.call(self._w, "start", interval)
-
-
-    def step(self, amount=None):
-        """Increments the value option by amount.
-
-        amount defaults to 1.0 if omitted."""
-        self.tk.call(self._w, "step", amount)
-
-
-    def stop(self):
-        """Stop autoincrement mode: cancels any recurring timer event
-        initiated by start."""
-        self.tk.call(self._w, "stop")
-
-
-class Radiobutton(Widget):
-    """Ttk Radiobutton widgets are used in groups to show or change a
-    set of mutually-exclusive options."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Radiobutton with parent master.
-
-        STANDARD OPTIONS
-
-            class, compound, cursor, image, state, style, takefocus,
-            text, textvariable, underline, width
-
-        WIDGET-SPECIFIC OPTIONS
-
-            command, value, variable
-        """
-        Widget.__init__(self, master, "ttk::radiobutton", kw)
-
-
-    def invoke(self):
-        """Sets the option variable to the option value, selects the
-        widget, and invokes the associated command.
-
-        Returns the result of the command, or an empty string if
-        no command is specified."""
-        return self.tk.call(self._w, "invoke")
-
-
-class Scale(Widget, tkinter.Scale):
-    """Ttk Scale widget is typically used to control the numeric value of
-    a linked variable that varies uniformly over some range."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Scale with parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus
-
-        WIDGET-SPECIFIC OPTIONS
-
-            command, from, length, orient, to, value, variable
-        """
-        Widget.__init__(self, master, "ttk::scale", kw)
-
-
-    def configure(self, cnf=None, **kw):
-        """Modify or query scale options.
-
-        Setting a value for any of the "from", "from_" or "to" options
-        generates a <<RangeChanged>> event."""
-        if cnf:
-            kw.update(cnf)
-        Widget.configure(self, **kw)
-        if any(['from' in kw, 'from_' in kw, 'to' in kw]):
-            self.event_generate('<<RangeChanged>>')
-
-
-    def get(self, x=None, y=None):
-        """Get the current value of the value option, or the value
-        corresponding to the coordinates x, y if they are specified.
-
-        x and y are pixel coordinates relative to the scale widget
-        origin."""
-        return self.tk.call(self._w, 'get', x, y)
-
-
-class Scrollbar(Widget, tkinter.Scrollbar):
-    """Ttk Scrollbar controls the viewport of a scrollable widget."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Scrollbar with parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus
-
-        WIDGET-SPECIFIC OPTIONS
-
-            command, orient
-        """
-        Widget.__init__(self, master, "ttk::scrollbar", kw)
-
-
-class Separator(Widget):
-    """Ttk Separator widget displays a horizontal or vertical separator
-    bar."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Separator with parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus
-
-        WIDGET-SPECIFIC OPTIONS
-
-            orient
-        """
-        Widget.__init__(self, master, "ttk::separator", kw)
-
-
-class Sizegrip(Widget):
-    """Ttk Sizegrip allows the user to resize the containing toplevel
-    window by pressing and dragging the grip."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Sizegrip with parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, state, style, takefocus
-        """
-        Widget.__init__(self, master, "ttk::sizegrip", kw)
-
-
-class Spinbox(Entry):
-    """Ttk Spinbox is an Entry with increment and decrement arrows
-
-    It is commonly used for number entry or to select from a list of
-    string values.
-    """
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Spinbox widget with the parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus, validate,
-            validatecommand, xscrollcommand, invalidcommand
-
-        WIDGET-SPECIFIC OPTIONS
-
-            to, from_, increment, values, wrap, format, command
-        """
-        Entry.__init__(self, master, "ttk::spinbox", **kw)
-
-
-    def set(self, value):
-        """Sets the value of the Spinbox to value."""
-        self.tk.call(self._w, "set", value)
-
-
-class Treeview(Widget, tkinter.XView, tkinter.YView):
-    """Ttk Treeview widget displays a hierarchical collection of items.
-
-    Each item has a textual label, an optional image, and an optional list
-    of data values. The data values are displayed in successive columns
-    after the tree label."""
-
-    def __init__(self, master=None, **kw):
-        """Construct a Ttk Treeview with parent master.
-
-        STANDARD OPTIONS
-
-            class, cursor, style, takefocus, xscrollcommand,
-            yscrollcommand
-
-        WIDGET-SPECIFIC OPTIONS
-
-            columns, displaycolumns, height, padding, selectmode, show
-
-        ITEM OPTIONS
-
-            text, image, values, open, tags
-
-        TAG OPTIONS
-
-            foreground, background, font, image
-        """
-        Widget.__init__(self, master, "ttk::treeview", kw)
-
-
-    def bbox(self, item, column=None):
-        """Returns the bounding box (relative to the treeview widget's
-        window) of the specified item in the form x y width height.
-
-        If column is specified, returns the bounding box of that cell.
-        If the item is not visible (i.e., if it is a descendant of a
-        closed item or is scrolled offscreen), returns an empty string."""
-        return self._getints(self.tk.call(self._w, "bbox", item, column)) or ''
-
-
-    def get_children(self, item=None):
-        """Returns a tuple of children belonging to item.
-
-        If item is not specified, returns root children."""
-        return self.tk.splitlist(
-                self.tk.call(self._w, "children", item or '') or ())
-
-
-    def set_children(self, item, *newchildren):
-        """Replaces item's child with newchildren.
-
-        Children present in item that are not present in newchildren
-        are detached from tree. No items in newchildren may be an
-        ancestor of item."""
-        self.tk.call(self._w, "children", item, newchildren)
-
-
-    def column(self, column, option=None, **kw):
-        """Query or modify the options for the specified column.
-
-        If kw is not given, returns a dict of the column option values. If
-        option is specified then the value for that option is returned.
-        Otherwise, sets the options to the corresponding values."""
-        if option is not None:
-            kw[option] = None
-        return _val_or_dict(self.tk, kw, self._w, "column", column)
-
-
-    def delete(self, *items):
-        """Delete all specified items and all their descendants. The root
-        item may not be deleted."""
-        self.tk.call(self._w, "delete", items)
-
-
-    def detach(self, *items):
-        """Unlinks all of the specified items from the tree.
-
-        The items and all of their descendants are still present, and may
-        be reinserted at another point in the tree, but will not be
-        displayed. The root item may not be detached."""
-        self.tk.call(self._w, "detach", items)
-
-
-    def exists(self, item):
-        """Returns True if the specified item is present in the tree,
-        False otherwise."""
-        return self.tk.getboolean(self.tk.call(self._w, "exists", item))
-
-
-    def focus(self, item=None):
-        """If item is specified, sets the focus item to item. Otherwise,
-        returns the current focus item, or '' if there is none."""
-        return self.tk.call(self._w, "focus", item)
-
-
-    def heading(self, column, option=None, **kw):
-        """Query or modify the heading options for the specified column.
-
-        If kw is not given, returns a dict of the heading option values. If
-        option is specified then the value for that option is returned.
-        Otherwise, sets the options to the corresponding values.
-
-        Valid options/values are:
-            text: text
-                The text to display in the column heading
-            image: image_name
-                Specifies an image to display to the right of the column
-                heading
-            anchor: anchor
-                Specifies how the heading text should be aligned. One of
-                the standard Tk anchor values
-            command: callback
-                A callback to be invoked when the heading label is
-                pressed.
-
-        To configure the tree column heading, call this with column = "#0" """
-        cmd = kw.get('command')
-        if cmd and not isinstance(cmd, str):
-            # callback not registered yet, do it now
-            kw['command'] = self.master.register(cmd, self._substitute)
-
-        if option is not None:
-            kw[option] = None
-
-        return _val_or_dict(self.tk, kw, self._w, 'heading', column)
-
-
-    def identify(self, component, x, y):
-        """Returns a description of the specified component under the
-        point given by x and y, or the empty string if no such component
-        is present at that position."""
-        return self.tk.call(self._w, "identify", component, x, y)
-
-
-    def identify_row(self, y):
-        """Returns the item ID of the item at position y."""
-        return self.identify("row", 0, y)
-
-
-    def identify_column(self, x):
-        """Returns the data column identifier of the cell at position x.
-
-        The tree column has ID #0."""
-        return self.identify("column", x, 0)
-
-
-    def identify_region(self, x, y):
-        """Returns one of:
-
-        heading: Tree heading area.
-        separator: Space between two columns headings;
-        tree: The tree area.
-        cell: A data cell.
-
-        * Availability: Tk 8.6"""
-        return self.identify("region", x, y)
-
-
-    def identify_element(self, x, y):
-        """Returns the element at position x, y.
-
-        * Availability: Tk 8.6"""
-        return self.identify("element", x, y)
-
-
-    def index(self, item):
-        """Returns the integer index of item within its parent's list
-        of children."""
-        return self.tk.getint(self.tk.call(self._w, "index", item))
-
-
-    def insert(self, parent, index, iid=None, **kw):
-        """Creates a new item and return the item identifier of the newly
-        created item.
-
-        parent is the item ID of the parent item, or the empty string
-        to create a new top-level item. index is an integer, or the value
-        end, specifying where in the list of parent's children to insert
-        the new item. If index is less than or equal to zero, the new node
-        is inserted at the beginning, if index is greater than or equal to
-        the current number of children, it is inserted at the end. If iid
-        is specified, it is used as the item identifier, iid must not
-        already exist in the tree. Otherwise, a new unique identifier
-        is generated."""
-        opts = _format_optdict(kw)
-        if iid is not None:
-            res = self.tk.call(self._w, "insert", parent, index,
-                "-id", iid, *opts)
-        else:
-            res = self.tk.call(self._w, "insert", parent, index, *opts)
-
-        return res
-
-
-    def item(self, item, option=None, **kw):
-        """Query or modify the options for the specified item.
-
-        If no options are given, a dict with options/values for the item
-        is returned. If option is specified then the value for that option
-        is returned. Otherwise, sets the options to the corresponding
-        values as given by kw."""
-        if option is not None:
-            kw[option] = None
-        return _val_or_dict(self.tk, kw, self._w, "item", item)
-
-
-    def move(self, item, parent, index):
-        """Moves item to position index in parent's list of children.
-
-        It is illegal to move an item under one of its descendants. If
-        index is less than or equal to zero, item is moved to the
-        beginning, if greater than or equal to the number of children,
-        it is moved to the end. If item was detached it is reattached."""
-        self.tk.call(self._w, "move", item, parent, index)
-
-    reattach = move # A sensible method name for reattaching detached items
-
-
-    def next(self, item):
-        """Returns the identifier of item's next sibling, or '' if item
-        is the last child of its parent."""
-        return self.tk.call(self._w, "next", item)
-
-
-    def parent(self, item):
-        """Returns the ID of the parent of item, or '' if item is at the
-        top level of the hierarchy."""
-        return self.tk.call(self._w, "parent", item)
-
-
-    def prev(self, item):
-        """Returns the identifier of item's previous sibling, or '' if
-        item is the first child of its parent."""
-        return self.tk.call(self._w, "prev", item)
-
-
-    def see(self, item):
-        """Ensure that item is visible.
-
-        Sets all of item's ancestors open option to True, and scrolls
-        the widget if necessary so that item is within the visible
-        portion of the tree."""
-        self.tk.call(self._w, "see", item)
-
-
-    def selection(self):
-        """Returns the tuple of selected items."""
-        return self.tk.splitlist(self.tk.call(self._w, "selection"))
-
-
-    def _selection(self, selop, items):
-        if len(items) == 1 and isinstance(items[0], (tuple, list)):
-            items = items[0]
-
-        self.tk.call(self._w, "selection", selop, items)
-
-
-    def selection_set(self, *items):
-        """The specified items becomes the new selection."""
-        self._selection("set", items)
-
-
-    def selection_add(self, *items):
-        """Add all of the specified items to the selection."""
-        self._selection("add", items)
-
-
-    def selection_remove(self, *items):
-        """Remove all of the specified items from the selection."""
-        self._selection("remove", items)
-
-
-    def selection_toggle(self, *items):
-        """Toggle the selection state of each specified item."""
-        self._selection("toggle", items)
-
-
-    def set(self, item, column=None, value=None):
-        """Query or set the value of given item.
-
-        With one argument, return a dictionary of column/value pairs
-        for the specified item. With two arguments, return the current
-        value of the specified column. With three arguments, set the
-        value of given column in given item to the specified value."""
-        res = self.tk.call(self._w, "set", item, column, value)
-        if column is None and value is None:
-            return _splitdict(self.tk, res,
-                              cut_minus=False, conv=_tclobj_to_py)
-        else:
-            return res
-
-
-    def tag_bind(self, tagname, sequence=None, callback=None):
-        """Bind a callback for the given event sequence to the tag tagname.
-        When an event is delivered to an item, the callbacks for each
-        of the item's tags option are called."""
-        self._bind((self._w, "tag", "bind", tagname), sequence, callback, add=0)
-
-
-    def tag_configure(self, tagname, option=None, **kw):
-        """Query or modify the options for the specified tagname.
-
-        If kw is not given, returns a dict of the option settings for tagname.
-        If option is specified, returns the value for that option for the
-        specified tagname. Otherwise, sets the options to the corresponding
-        values for the given tagname."""
-        if option is not None:
-            kw[option] = None
-        return _val_or_dict(self.tk, kw, self._w, "tag", "configure",
-            tagname)
-
-
-    def tag_has(self, tagname, item=None):
-        """If item is specified, returns 1 or 0 depending on whether the
-        specified item has the given tagname. Otherwise, returns a list of
-        all items which have the specified tag.
-
-        * Availability: Tk 8.6"""
-        if item is None:
-            return self.tk.splitlist(
-                self.tk.call(self._w, "tag", "has", tagname))
-        else:
-            return self.tk.getboolean(
-                self.tk.call(self._w, "tag", "has", tagname, item))
-
-
-# Extensions
-
-class LabeledScale(Frame):
-    """A Ttk Scale widget with a Ttk Label widget indicating its
-    current value.
-
-    The Ttk Scale can be accessed through instance.scale, and Ttk Label
-    can be accessed through instance.label"""
-
-    def __init__(self, master=None, variable=None, from_=0, to=10, **kw):
-        """Construct a horizontal LabeledScale with parent master, a
-        variable to be associated with the Ttk Scale widget and its range.
-        If variable is not specified, a tkinter.IntVar is created.
-
-        WIDGET-SPECIFIC OPTIONS
-
-            compound: 'top' or 'bottom'
-                Specifies how to display the label relative to the scale.
-                Defaults to 'top'.
-        """
-        self._label_top = kw.pop('compound', 'top') == 'top'
-
-        Frame.__init__(self, master, **kw)
-        self._variable = variable or tkinter.IntVar(master)
-        self._variable.set(from_)
-        self._last_valid = from_
-
-        self.label = Label(self)
-        self.scale = Scale(self, variable=self._variable, from_=from_, to=to)
-        self.scale.bind('<<RangeChanged>>', self._adjust)
-
-        # position scale and label according to the compound option
-        scale_side = 'bottom' if self._label_top else 'top'
-        label_side = 'top' if scale_side == 'bottom' else 'bottom'
-        self.scale.pack(side=scale_side, fill='x')
-        tmp = Label(self).pack(side=label_side) # place holder
-        self.label.place(anchor='n' if label_side == 'top' else 's')
-
-        # update the label as scale or variable changes
-        self.__tracecb = self._variable.trace_variable('w', self._adjust)
-        self.bind('<Configure>', self._adjust)
-        self.bind('<Map>', self._adjust)
-
-
-    def destroy(self):
-        """Destroy this widget and possibly its associated variable."""
-        try:
-            self._variable.trace_vdelete('w', self.__tracecb)
-        except AttributeError:
-            pass
-        else:
-            del self._variable
-        super().destroy()
-        self.label = None
-        self.scale = None
-
-
-    def _adjust(self, *args):
-        """Adjust the label position according to the scale."""
-        def adjust_label():
-            self.update_idletasks() # "force" scale redraw
-
-            x, y = self.scale.coords()
-            if self._label_top:
-                y = self.scale.winfo_y() - self.label.winfo_reqheight()
-            else:
-                y = self.scale.winfo_reqheight() + self.label.winfo_reqheight()
-
-            self.label.place_configure(x=x, y=y)
-
-        from_ = _to_number(self.scale['from'])
-        to = _to_number(self.scale['to'])
-        if to < from_:
-            from_, to = to, from_
-        newval = self._variable.get()
-        if not from_ <= newval <= to:
-            # value outside range, set value back to the last valid one
-            self.value = self._last_valid
-            return
-
-        self._last_valid = newval
-        self.label['text'] = newval
-        self.after_idle(adjust_label)
-
-    @property
-    def value(self):
-        """Return current scale value."""
-        return self._variable.get()
-
-    @value.setter
-    def value(self, val):
-        """Set new scale value."""
-        self._variable.set(val)
-
-
-class OptionMenu(Menubutton):
-    """Themed OptionMenu, based after tkinter's OptionMenu, which allows
-    the user to select a value from a menu."""
-
-    def __init__(self, master, variable, default=None, *values, **kwargs):
-        """Construct a themed OptionMenu widget with master as the parent,
-        the resource textvariable set to variable, the initially selected
-        value specified by the default parameter, the menu values given by
-        *values and additional keywords.
-
-        WIDGET-SPECIFIC OPTIONS
-
-            style: stylename
-                Menubutton style.
-            direction: 'above', 'below', 'left', 'right', or 'flush'
-                Menubutton direction.
-            command: callback
-                A callback that will be invoked after selecting an item.
-        """
-        kw = {'textvariable': variable, 'style': kwargs.pop('style', None),
-              'direction': kwargs.pop('direction', None)}
-        Menubutton.__init__(self, master, **kw)
-        self['menu'] = tkinter.Menu(self, tearoff=False)
-
-        self._variable = variable
-        self._callback = kwargs.pop('command', None)
-        if kwargs:
-            raise tkinter.TclError('unknown option -%s' % (
-                next(iter(kwargs.keys()))))
-
-        self.set_menu(default, *values)
-
-
-    def __getitem__(self, item):
-        if item == 'menu':
-            return self.nametowidget(Menubutton.__getitem__(self, item))
-
-        return Menubutton.__getitem__(self, item)
-
-
-    def set_menu(self, default=None, *values):
-        """Build a new menu of radiobuttons with *values and optionally
-        a default value."""
-        menu = self['menu']
-        menu.delete(0, 'end')
-        for val in values:
-            menu.add_radiobutton(label=val,
-                command=tkinter._setit(self._variable, val, self._callback),
-                variable=self._variable)
-
-        if default:
-            self._variable.set(default)
-
-
-    def destroy(self):
-        """Destroy this widget and its associated variable."""
-        try:
-            del self._variable
-        except AttributeError:
-            pass
-        super().destroy()
diff --git Misc/NEWS.d/next/Library/2018-05-08-08-03-34.bpo-33096.0hsFhL.rst Misc/NEWS.d/next/Library/2018-05-08-08-03-34.bpo-33096.0hsFhL.rst
new file mode 100644
index 000000000000..2fd23c73e3b6
--- /dev/null
+++ Misc/NEWS.d/next/Library/2018-05-08-08-03-34.bpo-33096.0hsFhL.rst
@@ -0,0 +1 @@
+Removed unintentionally backported from Python 3 Tkinter files.
